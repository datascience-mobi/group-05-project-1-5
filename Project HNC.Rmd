---
title: "Project Head and Neck Cancer"
author: "Nils Mechtel, Tobias Hub, Niklas Urbanek, Pascal Poc"
date: "8 July 2019"
output: html_document
---

```{r setup, include = FALSE}
#Global options
knitr::opts_chunk$set(echo = TRUE,
                      cache = TRUE,
                      comment=NA,
                      message = FALSE,
                      warning = FALSE)

# Library packages
library(knitr)      # RMarkdown
library(ggplot2)
library(ggpubr)     # histograms
theme_set(theme_pubr())
library(png)        # read, write and display images
library(tidyverse)  # data manipulation
library(cluster)    # clustering algorithms
library(factoextra) # clustering algorithms & visualization
library(igraph)     # networkplot
```
```{r eval = FALSE, include = FALSE}
# Set working directiory
root.dir = dirname(rstudioapi::getSourceEditorContext()$path)
```

# General Introduction
Head and neck cancer is defined as a group of cancers, concerning the mouth, nose and throat. With over 90%, Squamous cell carcinoma is the most common type in HNC patients. With 5.5 million affected people in 2015 it is the seventh most frequent cancer and the ninth most frequent cause of death. (Information required)

![](images/HNC_Kopf.png)


In the century of next generation sequencing, the genome became an interesting target for scientists. Approaches that directly affect important oncogenes often fail due to the fact that these genes play an important role in healthy cells. The researchers in our paper investigated synthetic lethality and synthetic dosage lethality that uses gene interactions to affect tumorous proliferation. Synthetic letahlity is a gene interaction in which single-gene defects are compatible with cell viability, but the combination of gene effects results in cell death. Synthetic dosage lethality occurs, when the overexpression of one gene is combined with the knockout of another gene.


![](images/Daisy.png)



# 1. Data Cleanup & Descriptive Statistics

## Loading data and defining HNC variables
```{r}
# Load dataset
allDepMapData = readRDS("DepMap19Q1_allData.RDS")

# Creation of sub matrices
expression = allDepMapData[["expression"]]
copynumber = allDepMapData[["copynumber"]]
mutation = allDepMapData[["mutation"]]
kd.ceres = allDepMapData[["kd.ceres"]]
kd.prob = allDepMapData[["kd.prob"]]
annotation = allDepMapData[["annotation"]]
rm(allDepMapData)

# Reducing the samples to head and neck cancer samples
annotation.HNC = annotation[which(annotation$Primary.Disease == "Head and Neck Cancer"), ]
ID = annotation.HNC$DepMap_ID

# Filtering of sub matrices by primary disease "Head and neck cancer"
expression.HNC = expression[ , which(colnames(expression) %in% ID)]
copynumber.HNC = copynumber[ , which(colnames(copynumber) %in% ID)]
kd.ceres.HNC = kd.ceres[ , which(colnames(kd.ceres) %in% ID)]
kd.prob.HNC = kd.prob[ , which(colnames(kd.prob) %in% ID)]
mutation.HNC = mutation[ID]
```

## Expression analysis


### Checking for NAs
```{r}
sum(is.na(expression) == TRUE)
```
Result: There are no NAs in the expression data.

### Examine expression values

Create a reference group of expression data
```{r}
'%!in%' = function(x,y)!('%in%'(x,y)) # Define function "is not in"

expression.reference = expression[ , which(colnames(expression) %!in% ID)]
```
and calculate their mean.
```{r}
mean.exp.reference = apply(expression.reference, 1, mean)
mean.exp.HNC = apply(expression.HNC, 1, mean)
```
Firstly, we want to check if the gene expressions of the HNC samples and the reference group are normally distributed.
```{r}
HNC = data.frame(expression_values = mean.exp.HNC, sample = "HNC") 
Reference = data.frame(expression_values = mean.exp.reference, sample = "Reference")
mean.expression = rbind(Reference, HNC)

ggqqplot(mean.expression, x = "expression_values",
   color = "sample",
   palette = c("#FC4E07", "#0073C2FF"), # red and blue
   ggtheme = theme_pubclean())
```

Result: Gene espression is neither in HNC samples nor in reference samples normally distributed.

Then we compare HNC and reference group gene expression using a statistical test. A Wilcoxon rank sum test must be applied because the expression is not normally distributed.
```{r}
wilcox.test(mean.exp.HNC, mean.exp.reference)
```
Result: Mean gene expression differs between HNC and reference group samples significantly.


Next we check if the gene expression differs whether a gene has a deleterious mutation or not. AS an example, we compare the mean TP53 gene expression of all samples with and without deleterious TP53 mutation.
```{r}
# Get the ID of samples whith and without deleterious mutation
TP53.mut.ID = lapply(1:length(mutation), function(a) {
  dat_picker = mutation[[a]]
  dat_picker = dat_picker[which(dat_picker$isDeleterious == TRUE),]
  out = ifelse("TP53" %in% dat_picker$Hugo_Symbol, a, NA) # filter all IDs which have a deleterious mutation of TP53
    return(out)
  })

TP53.not_mut.ID = grep("NA", TP53.mut.ID) # ID of samples with no TP53 mutation
TP53.mut.ID = as.integer(TP53.mut.ID[is.na(TP53.mut.ID) == FALSE]) # ID of samples with TP53 mutation

# Create two vectors of expression values
exp.TP53.mut = as.numeric(expression["TP53", TP53.mut.ID]) # expression of TP53 deleterious mutated samples
exp.TP53.not_mut = as.numeric(expression["TP53", TP53.not_mut.ID]) # expression of TP53 not deleterious mutated samples
```
Compare the expression values by applying Wilcoxon rank sum test.
```{r}
wilcox.test(exp.TP53.mut , exp.TP53.not_mut)
```
Result: Gene expression of TP53 as an example gene varies significantly whether the samples has or has no deleterious TP53 mutation.

At last, we plot a histogram to check how the expression values are distributed.
```{r}
gghistogram(as.data.frame(mean.exp.HNC),
            x = "mean.exp.HNC",
            xlab = "expression value",
            bins = 60,
            fill = "#0073C2FF",
            color = "#0073C2FF",
            add = "mean",
            rug = TRUE)
```


Result: The most genes have expression values around 0.



### Plot the 20 most under- and overexpressed genes of HNC samples.
For this we need to normalize the expression data from HNC samples
```{r}
expr.HNC.norm = as.data.frame(apply(expression.HNC, 2, function(x) {
  x - mean.exp.reference
}))
```
and calculate the mean of the normalesid expression values.
```{r}
mean.expr.HNC.norm = as.data.frame(apply(expr.HNC.norm, 1, mean))
```

Then create a dataframe with needed information for the barplot
```{r}
barplot.data = data.frame(Genes=rownames(expr.HNC.norm),
                          Values=mean.expr.HNC.norm)
names(barplot.data) = c("Genes", "Values")
barplot.data$Group = ifelse(barplot.data$Values>0,"overexpressed","underexpressed")
barplot.data = barplot.data[order(barplot.data$Values),]
barplot.data = barplot.data[c(1:19, (nrow(barplot.data)-20):nrow(barplot.data)),]
```
and plot this dataframe.
```{r}
ggplot(barplot.data,aes(x=Genes,y=Values,fill=Group))+geom_bar(stat="identity")+coord_flip()+theme(axis.text.y = element_text(size=6))
```

### Cleanup of the enviroment
```{r}
rm(HNC, Reference, mean.expression, TP53.mut.ID, TP53.not_mut.ID, exp.TP53.mut, exp.TP53.not_mut, mean.expr.HNC.norm, barplot.data, mean.exp.HNC, mean.exp.reference, expression.reference)
```

## Copynumber Alteration
### Analysis of NA values

Examination of NA values in the copynumber.HNC data
```{r}
# sum up all NAs in each row
NA.rows = apply(copynumber.HNC,1, function(x) {
          sum(is.na(x))
})
#define all rows cotaining missing values
NA.rows = which( NA.rows > 0)
length(NA.rows)
```
Only 107 out of 23299 gens have NA values and are therefore deleted from the copynumber.HNC dataframe
```{r}
copynumber.HNC = copynumber.HNC[-NA.rows,]
dim(copynumber.HNC)
```
Creating a reference data and examination of its NA values
```{r}
copynumber.reference = copynumber[,which(colnames(copynumber) %!in% ID)]
dim(copynumber.reference)
```

```{r}
NA.rows.ref = apply(copynumber.reference,1, function(x) {
          sum(is.na(x))
})
NA.rows.ref = which( NA.rows.ref > 0)
length(NA.rows.ref)
```

```{r}
summary(NA.rows == NA.rows.ref)
```
Genes with NA values are the same for the HNC samples and all the other samples. Therefore, they can be deleted in the reference data as well.

```{r}
copynumber.reference = copynumber.reference[-NA.rows.ref,]
copynumber = copynumber[-NA.rows.ref,]
dim(copynumber.reference)
dim(copynumber)
```
### Normalisation of the copynumber values

For the HNC normalisation we will use the mean CN value per gen of the reference data.

```{r}
copynumber.ref.mean = apply(copynumber.reference,1, mean)
copynumber.HNC.mean = apply(copynumber.HNC ,1, mean)
```

Creating a dataframe of all copynumber values. The values are normalized to the mean copynumbers of the reference data.
```{r}
cna.HNC.norm = as.data.frame(apply(copynumber.HNC, 2, function(x) {
  x - copynumber.ref.mean
}))
```

Creating a dataframe of HNC copynumber values. The values are normalized to the mean copynumbers of the reference data. For further analysing the dataframe is ordered in a decreasing manner.
```{r}
Values = copynumber.HNC.mean - copynumber.ref.mean
copynumber.HNC.norm = data.frame(values = sort(Values, decreasing = TRUE), genes = row.names(copynumber.HNC))
copynumber.HNC.norm$Group = ifelse(copynumber.HNC.norm$values > 0,"high CN","low CN")
```

Plotting genes with the highest and lowest copynumbers.
```{r}
ggplot(copynumber.HNC.norm[c(1:20,23172:23192),],aes(x=genes,y=values,fill=Group))+geom_bar(stat="identity")+coord_flip()+theme(axis.text.y = element_text(size=6))
```
### Cleanup of the environment
```{r}
rm(NA.rows, NA.rows.ref, copynumber.HNC.norm, copynumber.HNC.mean, copynumber.ref.mean, copynumber.reference, Values)
```

## Mutation

### Find Mutations with the highest frequencies

Melt all mutation matrices together and find most often mutated genes over all samples
```{r}
all_mutations = do.call(rbind,mutation)
all_mutated_genes = table(all_mutations$Hugo_Symbol)
all_mutated_genes_df = as.data.frame(all_mutated_genes)
ID_all_highest_frequencies = head(order(all_mutated_genes_df[["Freq"]], decreasing = TRUE), 30)
all_mutated_genes_df_highest_30 = all_mutated_genes_df[which(rownames(all_mutated_genes_df) %in% ID_all_highest_frequencies), ]
ID_all_highest_30_frequencies = order(all_mutated_genes_df_highest_30["Freq"], decreasing = TRUE) 
all_mutated_genes_df_highest_30_ordered = all_mutated_genes_df_highest_30[ID_all_highest_30_frequencies, ]
rownames(all_mutated_genes_df_highest_30_ordered) = 1:30
colnames_ordered = c("Gene", "Freq")
colnames(all_mutated_genes_df_highest_30_ordered) = colnames_ordered
```

Melt only HNC sample mutation matrices together and find most often mutated genes 
```{r}
HNC_mutations = do.call(rbind, mutation.HNC)
HNC_mutated_genes = table(HNC_mutations$Hugo_Symbol)
HNC_mutated_genes_df = as.data.frame(HNC_mutated_genes)
ID_HNC_highest_frequencies = head(order(HNC_mutated_genes_df[["Freq"]], decreasing = TRUE), 27)  
HNC_mutated_genes_df_highest_ordered = HNC_mutated_genes_df[ID_HNC_highest_frequencies, ]
rownames(HNC_mutated_genes_df_highest_ordered) = 1:27
colnames(HNC_mutated_genes_df_highest_ordered) = colnames_ordered
```

### Plotting mutation frequencies of all samples and of HNC samples

Plot mutations in all samples
```{r}
all_mut_plot = ggplot(data = all_mutated_genes_df_highest_30_ordered, aes(x=Gene, y=Freq)) + geom_bar(stat = "identity", width = 0.5, fill="steelblue") +  geom_text(aes(label=Freq), vjust=-0.3, size=2.5) + theme_grey() + coord_flip()

all_mut_plot
```

Plot mutations in HNC samples
```{r}
HNC_mut_plot = ggplot(data = HNC_mutated_genes_df_highest_ordered, aes(x=Gene, y=Freq)) + geom_bar(stat = "identity", width = 0.5, fill="steelblue") + geom_text(aes(label=Freq), vjust=-0.3, size=3.5) + theme_grey()+ coord_flip()
HNC_mut_plot
```

### Cleanup of the enviroment
```{r}
rm(all_mutations, all_mutated_genes, all_mutated_genes_df, ID_all_highest_30_frequencies, ID_all_highest_frequencies, all_mutated_genes_df_highest_30, all_mutated_genes_df_highest_30_ordered, colnames_ordered, HNC_mutations, HNC_mutated_genes, HNC_mutated_genes_df, ID_HNC_highest_frequencies, HNC_mutated_genes_df_highest_ordered, HNC_mut_plot, all_mut_plot)
```

## Knockdown

### Checking for NAs and range in HNC patients
```{r}
sum(is.na(kd.ceres.HNC) == TRUE) #NAs
range(kd.ceres.HNC)# Range of data
```
### Definition of a compare group
```{r}
kd.ceres.reference = kd.ceres[ , -which(colnames(kd.ceres) %in% ID)]

# Comparing mean knockdown data of all samples with just HNC samples
mean.kd.ceres.reference = apply(kd.ceres.reference, 1, mean)
mean.kd.ceres = apply(kd.ceres.HNC, 1, mean)

# Checking if knockdown values are normally distributed
kd.ceres.HNC.dist = data.frame(kd_values = mean.kd.ceres, sample = "Knockdown HNC")
kd.ceres.reference.dist = data.frame(kd_values = mean.kd.ceres.reference, sample = "reference HNC")
mean.kd.ceres.dist = rbind(kd.ceres.reference.dist, kd.ceres.HNC.dist)

ggqqplot(mean.kd.ceres.dist, x = "kd_values",
   color = "sample",
   palette = c("#FC4E07", "#0073C2FF"),
   ggtheme = theme_grey())

# Are there genes that tend to be more essential in HNC?
esgene1 = kd.ceres.HNC[-which(rowMeans(kd.ceres.HNC)> rowMeans(kd.ceres.reference)),]
#Sort essential genes 
esgene1= esgene1[order(rowMeans(esgene1)),]

```
result: kd.ceres values are not normal distributed

### Checking the distribution for knockdown values
```{r}
gghistogram(kd.ceres.HNC.dist, x = "kd_values", xlab = "knockdown values", bins = 60,
            fill = "#0073C2FF", color = "#0073C2FF",
            add = "mean", rug = TRUE)+theme_grey()
```
### Applying Wilcoxon rank sum test because knockdown values are not normally distributed
```{r}
wilcox.test(mean.kd.ceres, mean.kd.ceres.reference)
```
Resultat Fehlt
### Example EGFR
```{r}
# Transposition of dataframe esgene1
esgeneT = as.data.frame(t(esgene1))
summary(esgeneT$EGFR)
```

### Boxplot of 20 genes
```{r}
#boxplot of 20 of most significiant genes according to knockdown analysis
boxplot(esgeneT[,1:20], xlab = "gene", horizontal = F, main="Knockdown values of most significiant genes",
        xlab="genes",
        ylab="Knockdown values",
        col="blue",
        border="brown",
        outline = TRUE,
        notch = TRUE)
abline(col = c("blue", "red", "black", "orange"),
    lty = 2)
```
### Cleanup of the enviroment
```{r}
rm(kd.ceres.HNC.dist, kd.ceres.reference, kd.ceres.reference.dist, mean.kd.ceres, mean.kd.ceres.reference, mean.kd.ceres.dist, esgene1, esgeneT)
```

# 2. Identify genes of interest

## k-means clustering of CNA and expression data with normalized values(-reference) for SDL GOI

```{r}
km.genes = Reduce(intersect, list(rownames(expression.HNC), rownames(copynumber.HNC)))
km.expression = expr.HNC.norm[km.genes,]
km.copynumber = cna.HNC.norm[km.genes,]
km.data = lapply(1:length(ID), function(x) {
  out = data.frame(genes =km.genes, expression = km.expression[,x], copynumber = km.copynumber[,x])
  return (out)
})

comb.ex.cna = do.call(rbind, km.data)
comb.ex.cna = comb.ex.cna[which(comb.ex.cna$copynumber >= 1 & comb.ex.cna$expression >=quantile(comb.ex.cna$expression,0.95)),]

#Plotting of normalized expression valuess against CNA data. 
ggplot(comb.ex.cna[,2:3], aes(x= expression, y= copynumber , color = "smooth")) + geom_point()

#ellbow method to find optimal ammount of clusters
emp = vector() #create an empty vector to save the summ-of weights scores
for (i in 1:10) emp[i] = sum(kmeans(comb.ex.cna[2:3], i)$withinss) #calculate the sum within squared values for 10 clusters
emp #look at the sum within squares for 10 clusters 
#Plotting of Ellbow method
plot(1:10,
     emp,
     type = 'b',
     main = paste('The Elbow Method'),
     xlab = 'Number of clusters',
     ylab = 'EMP') 
# shows 3 clusters are sufficient

# Fitting K-Means to the dataset
kmeans = kmeans(x = comb.ex.cna[,2:3], centers = 3,iter.max = 1000, nstart = 1) #see elbow method (k = 5) and apply kMeans clustering onto the dataset of the customers
y_kmeans = kmeans$cluster #the consumers get put into a specific cluster; extract this information 

# Visualising the clusters
clusplot(comb.ex.cna,
         y_kmeans,
         lines = 0,
         shade = TRUE,
         color = TRUE,
         labels = 4,
         plotchar = FALSE,
         span = TRUE,
         stand = FALSE,
         cex =0.5,
         main = paste('Clusters of Genes'),
         xlab = 'Expression',
         ylab = 'CNA')

comb.ex.cna = cbind(comb.ex.cna, y_kmeans)#combine kmeans with genes
#sort comb.ex.cna data decresing for selecting adequate number of cluster
comb.ex.cna = comb.ex.cna[order(comb.ex.cna$expression,decreasing =TRUE),]

#Filtering of the most expressed and alterated
goi.sdl = comb.ex.cna[which(comb.ex.cna$y_kmeans == comb.ex.cna[1,4]),]

#sort dataframe 
goi.sdl = goi.sdl[order(goi.sdl$expression,decreasing=TRUE),]
kable(head(goi.sdl))

goi.SDL = rownames(goi.sdl)[1:5]
rm(emp, i, km.genes, y_kmeans, kmeans, km.copynumber, km.data, km.expression, comb.ex.cna) # Clean enviroment
```

## Investigate high frequencies of deleterious mutations SL GOI

Create a dataframe with data for the heatmap.
```{r}
mutation.HNC.df = do.call(rbind, mutation.HNC) # all mutation data of HNC samples in one dataframe
heatmap.genes = as.data.frame(table(mutation.HNC.df$Hugo_Symbol)) # dataframe with all mutated genes in HNC samples just once

heatmap.data = as.data.frame(sapply(1:(length(ID)), function(a) {
  out = ifelse(heatmap.genes$Var1 %in% mutation.HNC[[a]]$Hugo_Symbol, 1, 0) # per HNC sample: every gene which is mutated gets a 1, otherwise a 0
  return(out)
}))

# define row and column names
rownames(heatmap.data) = heatmap.genes$Var1
colnames(heatmap.data) = ID

# Order from high to low frequency
heatmap.data$sum = apply(heatmap.data, 1, sum)
heatmap.data = heatmap.data[order(-heatmap.data$sum), 1:27] 

# heatmap of the most frequently mutated genes in HNC samples
heatmap(data.matrix(heatmap.data)[1:40,], Rowv=NA, Colv=NA, col = c("lightgrey", "tomato2"), scale="column", cexRow = 0.5, cexCol = 0.8, main = "Most frequently mutated genes in HNC samples")
```

Result: TP53, FAT1, CDKN2A, KRT3 and CASP8 are the 5 most frequently mutated genes in our HNC samples

According to Leemans et al. (2018) these are frequent mutations in HNC:
![](images/frequent_mutations_HNC.png)

Leemans, C. R. et al. (2018). The molecular landscape of head and neck cancer. Nat. Rev. Cancer 18, 269-282.


Compare our SL GOI with genes from literature.
```{r}
goi.lit = data.frame(Gene = c("CDKN2A", "TP53", "CCND1", "EGFR", "PIK3CA", "PTEN", "FAT1", "AJUBA", "NOTCH1", "KMT2D", "NSD1"), "Mutation frequency" = c(22, 72, 0.6, 4, 18, 3, 23, 7, 18, 16, 12), "CNA frequency" = c(32, 1.4, 25, 11, 21, 4, 8, 1, 4, 0.4, 0.8)) # create dataframe with goi from literature

heatmap_position = sapply(1:nrow(goi.lit), function(a) { # search for the position of goi.lit in mutated genes of HNC samples
  position = which(rownames(heatmap.data) == goi.lit$Gene[a])
  if(length(position) == 0) {position = NA} # if gene is not part of the genes mutated in HNC samples its position is replaced with NA
  return(position)
})

goi.lit$"Heatmap position" = heatmap_position # add heatmap position to goi.lit
rownames(goi.lit) = goi.lit$Gene
goi.lit$Gene = NULL
goi.lit = goi.lit[order(goi.lit$"Heatmap position"),]
kable(goi.lit) # show a table of goi.lit
```

Because our most frequent mutated genes almost aproximately match with frequent mutations from literature we choose the 5 genes with most frequent mutations in HNC samples.
```{r}
goi.SL = rownames(heatmap.data)[1:5]
```

Clean up of the enviroment
```{r}
rm(mutation.HNC.df, heatmap.genes, heatmap.data, heatmap_position)
```

# 3. Find SL/SDL partner

## SL/SDL partner search following the daisy model

To examine gene pairs A and B which fulfill the criteria of SoF and functional examination we performe a Wilcoxon rank sum test on copynumber or CERES knockdown data. We have 5 inactive genes (goi.SL) and 5 overactive genes (goi.SDL) which are defined as genes A. The Wilcoxon rank sum test now returns all genes B which pass the test in a significant manner (p<0.05). 
```{r}
'Daisy.Wilcox' = function(input_genes,input_data, inactive_overactive, less_greater){
  Daisy_Wilcox = lapply(1:length(input_genes), function(m) {
  goi = input_genes[m] # set 1 of 5 goi
  # depending on SL or SDL partner search gene B needs to be inactive (SL) or overactive (SDL)
  if(inactive_overactive == 1) { # inactive_overactive == 1 chooses overactive
    mean.exp.goi = mean(t(expression[goi,]))
    exp.goi.norm = expression[goi,] - mean.exp.goi # normalised expression values of goi
    mut_overa.ID = lapply(1:ncol(expression), function(a) {
    out = if(exp.goi.norm[goi, a] > 0 & copynumber[goi,a] > 0.3) {a} else {NA} # filter all IDs which are overactive: overexpressed and CNA > 0,3
    return(out)
    })
  } else { # inactive_overactive == 0 chooses inactive
    mut_overa.ID = lapply(1:length(mutation), function(a) {
    out = ifelse(goi %in% mutation[[a]]$Hugo_Symbol, a, NA) # filter all IDs which have a mutation of goi
    return(out)
    })
  }
  
  not_mut_overa.ID = grep("NA", mut_overa.ID) # ID of samples which have NO inactivity/overactivity of goi
  mut_overa.ID = as.integer(mut_overa.ID[is.na(mut_overa.ID) == FALSE]) # ID of samples which HAVE inactivity/overactivity of goi

  p.value = sapply(1:nrow(input_data), function(b) {
    mut_overa.data = t(input_data[b, mut_overa.ID])
    not_mut_overa.data = t(input_data[b, not_mut_overa.ID])
    if (less_greater == 1) {
      p = wilcox.test(mut_overa.data, not_mut_overa.data, alternative = "greater")$p.value # one sided (greater) Wilcoxon Sum Rank Test 
    } else {
      p = wilcox.test(mut_overa.data, not_mut_overa.data, alternative = "less")$p.value # one sided (greater) Wilcoxon Sum Rank Test
    }
    
  })

  out = data.frame(genes = rownames(input_data), p_value = p.value)
  out = out[which(out$p_value < 0.05),]
  return(out)
  })
  names(Daisy_Wilcox) = input_genes
  return(Daisy_Wilcox)
}
```

To examine gene pairs A and B which fulfill the criteria of gene co expresssion we performe a Spearman correlation test on the expression data. We have 5 inactive genes (goi.SL) and 5 overactive genes (goi.SDL) which are defined as genes A The correlation test now returns all genes B that correlate to gene A in a significant manner (p<0.05).
```{r}
'Daisy.Spearman' = function(input_genes){
  Daisy_Spearman = lapply(1:length(input_genes), function(m) { # build up a list with the 5 goi, first       lapply: goes through the code for each gene A
  goi = input_genes[m]

  p.value = sapply(1:nrow(expression), function(a){  # creation of a list with the length of the expression   data, for the reacent goi, go through every gene and calculate cor.test
    expression.goi =t(expression[goi,])           # variable containing expressiondata of the goi (gene A)
    expression.GeneB =t(expression[a,])           # variable containing all other genes (gene B)
    p = cor.test(expression.goi,expression.GeneB, alternative = "greater", method = "spearman", exact = FALSE)$p.value # one sided spearman correlation test  
  })
  
  # return a dataframe with the columns genes(HugoSymbols) and p_values (p.values)
  out = data.frame(genes = rownames(expression), p_value = p.value)
  out = out[which(out$p_value < 0.05),] # filter for significant p.values
  out = out[which(out$genes != goi),]   # select onl these wich are not the same gene as the goi (would be a corr of 1)
  return(out)
  })
  names(Daisy_Spearman) = input_genes
  return(Daisy_Spearman)
}
```


Both functions return a list, which contains the five genes of interest, each containing a dataframe with all genes examined as potential SL/SDL partners plus their calculated p-values.


### SL-parter
SoF
```{r}
SL.SoF = Daisy.Wilcox(goi.SL, copynumber, inactive_overactive = 0, less_greater = 1) # SoF, inactive, one sided Wilcoxon rank test, alternative = "greater"
```
Functional examination
```{r}
SL.functional.examination = Daisy.Wilcox(goi.SL, kd.ceres, inactive_overactive = 0, less_greater = 0) # Functional examination, inactive, one sided Wilcoxon rank test, alternative = "less"
```
Gene coexpression
```{r}
SL.coexpression = Daisy.Spearman(goi.SL)
```

### SDL-parter
SoF
```{r}
SDL.SoF = Daisy.Wilcox(goi.SDL, copynumber, inactive_overactive = 1, less_greater = 1) # SoF, overactive, one sided Wilcoxon rank test, alternative = "greater"
```
Functional examination
```{r}
SDL.functional.examination = Daisy.Wilcox(goi.SDL, kd.ceres, inactive_overactive = 1, less_greater = 0) # Functional examination, overactive, one sided Wilcoxon rank test, alternative = "less"
```
Gene coexpression
```{r}
SDL.coexpression = Daisy.Spearman(goi.SDL)
```

## Converging the different SL and SDL sets

Define function to converge SL/SDL sets.
```{r}
'partner' = function(input_genes, SoF, functional.examination, coexpression){
  partner = lapply(1:length(input_genes), function(a) {
    dat_picker.SoF = SoF[[a]]
    dat_picker.functional_examination = functional.examination[[a]]
    dat_picker.coexpression = coexpression[[a]]
    partnergenes = Reduce(intersect, list(dat_picker.SoF$genes, dat_picker.functional_examination$genes, dat_picker.coexpression$genes)) # Intersect of genes from all three tests
    out = data.frame(genes = partnergenes, # column with reduced genes
                     SoF = dat_picker.SoF[which(dat_picker.SoF$genes %in% partnergenes),"p_value"], # column with p value from SoF
                     functional_examination = dat_picker.functional_examination[which(dat_picker.functional_examination$genes %in% partnergenes),"p_value"], # column with p value from functional examination
                     coexpression = dat_picker.coexpression[which(dat_picker.coexpression$genes %in% partnergenes),"p_value"]) # column with p value from coexpression
    return(out)
  })
  names(partner) = input_genes
  return(partner)
}
```
Converge different sets.
```{r}
SL.partner = partner(goi.SL, SL.SoF, SL.functional.examination, SL.coexpression)
SDL.partner = partner(goi.SDL, SDL.SoF, SDL.functional.examination, SDL.coexpression)
kable(data.frame("SL genes" = names(SL.partner),
           "SL partner" = sapply(1:length(SL.partner), function(a){nrow(SL.partner[[a]])}),
           "SDL genes" = names(SDL.partner),
           "SDL partner" = sapply(1:length(SDL.partner), function(a){nrow(SDL.partner[[a]])})
           ))
```

## Plotting networks of the Interactions 

Creation of a function for transforming given data into a format iGraph can work with and plotting of the network
```{r}
'network' = function(X.partner,width,node.color,frame.color,node.size,Titel,label){#(SL/SDL.partner,number,string,string,number,string,NA oder names(plot))
  
  color.vector = c("darkred", "darkgreen", "turquoise", "yellow", "orange") #define colours
# transform data into a dataframe with 3 colums for each GOI  
  edgelist = lapply(1:length(X.partner), function(a){
    dat_picker = X.partner[[a]]
    edge.list = data.frame(Gene.A = names(X.partner)[a], Gene.B = dat_picker$genes, colours = color.vector[a]) #the 3 columns
  })
  edge.list = do.call(rbind, edgelist)#combine all goi-dataframes to one.

  edge.list$colours = as.character(edge.list$colours) #after the lapply, column "colours" has class 'factor'. For the plottingfunction it must be character 
  
  net = graph_from_data_frame(edge.list, directed = T) # tranform the dataframe into an iGraph object
  layout1 = layout_with_kk(net)                        # given layout

#plotting parameters are defined. vertex= Genes edges = interactions 
  plot(net, layout = layout1, rescale = T, ylim = c(-0.9,1), xlim = c(-0.02,-0.1), edge.color = edge.list$colours , edge.width = width, edge.arrow.mode = 0, vertex.color = node.color,vertex.frame.color = frame.color, vertex.size = node.size, vertex.label.font = 2, vertex.label.color = "black", main = Titel, vertex.label = label)

#adding a legend to the plot
  legend (x = 1.2, y = 1, goi.SL,  fill = c("darkred", "darkgreen", "turquoise", "yellow", "orange"))
}

```


Creating a networkplot for the SL-partner
```{r}
network(SL.partner,2,"grey","black",8.1,"Network of SL interaction", NA )
```

Creating a network for the SDL-partner 
```{r}
network(SDL.partner,2,"grey","black",8.1,"Network of SDL interaction", NA )
         
```

Because there are to many SL/SDL partner to plot a network we reduce SL/SDL partner to the most significants.
To do so, we reduce the number of partner genes for better plotting without removing genes which are connected to more than one GOI.
```{r}
'reduce.partner' = function(list){ 
  reduced_partner = lapply(1:length(list), function(a){ # go through every element of SL/SDL partner
    dat_picker = list[[a]]
    
    if (nrow(dat_picker) > 20) { # (1) if length of dat_picker is larger than 20 reduce to the 20 most significant plus the genes we want to keep
      
      dat_picker$order = apply(dat_picker[,2:4], 1, mean) # create an extra column with the mean p value of all 3 tests
      ordered_data = dat_picker[order(dat_picker$order),][,1:4] # order the partner genes after this mean value from most to least significant p value
      
      gene_intersect = lapply(1:length(list), function(b){ 
          as.list(Reduce(intersect, list(dat_picker$genes), list[[b]]$genes)) # search for genes that are partner for more than one GOI
      })
      gene_intersect[a] = NULL # remove intersect of the GOI partner genes with itself
      keep_genes = c(gene_intersect[[1]], gene_intersect[[2]], gene_intersect[[3]], gene_intersect[[4]]) # combine all the genes in a list
      position = sapply(1:length(keep_genes), function(c){
        which(as.character(ordered_data$genes) == keep_genes[c])
      })
      position = position[which(position > 20)] # partner genes that are already in the first 20 genes don´t need to be chosen
      
      if(length(position) > 3) {position = position[1:3]} # if there are still more than 3 extra genes only choose the first 5
      out = ordered_data[c(1:20, position),]
      return(out) # return reduced data
    } else {
      return(ordered_data) # (2) if length of dat_picker is smaller than 20 return data unreduced 
    }
  })
  names(reduced_partner) = names(list)
  return(reduced_partner)
}
```

Reduce SL.parter/SDL.partner to the most significant
```{r}
SL.partner.reduced = reduce.partner(SL.partner)
SDL.partner.reduced = reduce.partner(SDL.partner)
SDL.partner.reduced[[3]][24,] = SDL.partner[[3]][which(SDL.partner[[3]]$genes == "FOSL1"),]

kable(data.frame("SL genes" = names(SL.partner),
           "SL partner" = sapply(1:length(SL.partner.reduced), function(a){nrow(SL.partner.reduced[[a]])}),
           "SDL genes" = names(SDL.partner),
           "SDL partner" = sapply(1:length(SDL.partner.reduced), function(a){nrow(SDL.partner.reduced[[a]])})
           ))
```

Now the number of SL/SDL partner is much better to plot.


Plotting SL/SDL partner network with reduced number of partner

SL interaction plot with reduced partners
```{r}
network(SL.partner.reduced,4,"grey","grey",12,"Network of SL interaction (reduced)", names(plot) )
```

SDL interaction plot with reduced partners
```{r}
network(SDL.partner.reduced,4,"grey","grey",12,"Network of SDL interaction (reduced)", names(plot) )
```

# 4. Mutation prediction via logistical regression
## Prepare data for regression model
Reduce all genes to them of which we have expression, copynumber and knockdown data.
```{r}
regression.genes = Reduce(intersect, list(rownames(expression), rownames(copynumber), rownames(kd.ceres)))

regression.expression = expression[regression.genes,]
regression.copynumber = copynumber[regression.genes,]
regression.kd.ceres = kd.ceres[regression.genes,]
```
Create a dataframe with expression, copynumber, knockdown and mutation data from all samples one after another.
```{r}
regression.data = lapply(1:length(regression.genes), function(a) {
  rg.expr = t(regression.expression[a,])
  rg.cna = t(regression.copynumber[a,])
  rg.kd = t(regression.kd.ceres[a,])
  rg.mut = sapply(1:length(mutation), function(m) {
    out = ifelse(regression.genes[a] %in% mutation[[m]]$Hugo_Symbol, TRUE, FALSE)
    return(out)
  })
  out = data.frame("genes" = regression.genes[a], "expression" = rg.expr, "copynumber" = rg.cna, "kockdown" = rg.kd, "mutation" = rg.mut)
  colnames(out) = c("genes", "expression", "copynumber", "kockdown", "mutation")
  return(out)
})
regression.data = do.call(rbind, regression.data)
rm(regression.genes, regression.expression, regression.copynumber, regression.kd.ceres)
```
## train regression model
## test regression model and compare different variable input
