---
title: "Project Head and Neck Cancer"
author: "Nils Mechtel, Tobias Hub, Niklas Urbanek, Pascal Poc"
date: "21 July 2019"
output: pdf_document
---

```{r setup, include = FALSE}
#Global options
knitr::opts_chunk$set(echo = TRUE,
                      cache = TRUE,
                      comment = NA,
                      message = FALSE,
                      warning = FALSE)

# Library packages
library(knitr)      # RMarkdown
library(rstudioapi)
library(ggplot2)
library(ggpubr)     # Histograms
theme_set(theme_pubr())
library(png)        # Read, write and display images
library(tidyverse)  # Data manipulation
library(cluster)    # Clustering algorithms
library(factoextra) # Clustering algorithms & visualization
library(igraph)     # Networkplot
library(caTools)
library(caret)
library(data.table)

```
```{r wd, eval = FALSE, include = FALSE}
# Set working directiory
root.dir = dirname(rstudioapi::getSourceEditorContext()$path)
```

# General Introduction
Head and neck cancer is defined as a group of cancers, concerning the mouth, nose and throat. With over 90%, Squamous cell carcinoma is the most common type in HNC patients. With 5.5 million affected people in 2015 it is the seventh most frequent cancer and the ninth most frequent cause of death. 75% of all HNC cancer types were caused by tobacco or alcohol. Although the cure rate for HNC is really high, around 50 % of concerned patients remain suffering from an advanced disease .

![](images/HNC_Kopf.png)


In the century of next generation sequencing, the genome became an interesting target for scientists. Approaches that directly affect important oncogenes often fail due to the fact that these genes play an important role in healthy cells. The researchers in our paper investigated synthetic lethality and synthetic dosage lethality that uses gene interactions to affect tumorous proliferation. Synthetic letahlity is a gene interaction in which single-gene defects are compatible with cell viability, but the combination of gene effects results in cell death. Synthetic dosage lethality occurs, when the overexpression of one gene is combined with the knockout of another gene.


![](images/Daisy.png)



Daisy consists of three statistical approaches, each processing different sub data from a cancer Dataset. The first strategy is “Survival of the fittest”, where just deleted SL-paired genes were selected, that are not in a surviving cancer culture. The second strategy is “functional examination” where SL genes were identified, by knocking out genes, with the additive, that the SL partners are inactive. If the tumor shows decreased proliferation, it accounts for the SL pair group. The third strategy is “pairwise gene co- expression” that is based on the fact that SL pairs are often closely related in biological pathways and therefore exhibit similar occurrence. If a gene pair fulfills every of the three criteria, it might be a potential SL pair according to DAISY. To check for SDL partners the criteria of inactive or active is replaced by under- or overactive, measured through expression numbers and copy number alterations.

## Milestones
![](images/milestones.png)


# 1. Data Cleanup & Descriptive Statistics

## Loading data and defining HNC variables
```{r load_data}
# Load dataset
allDepMapData = readRDS("DepMap19Q1_allData.RDS")

# Creation of sub matrices
expression = allDepMapData[["expression"]]
copynumber = allDepMapData[["copynumber"]]
mutation = allDepMapData[["mutation"]]
kd.ceres = allDepMapData[["kd.ceres"]]
kd.prob = allDepMapData[["kd.prob"]]
annotation = allDepMapData[["annotation"]]
rm(allDepMapData)

# Reducing the samples to head and neck cancer samples
annotation.HNC = annotation[which(annotation$Primary.Disease == "Head and Neck Cancer"), ]
ID = annotation.HNC$DepMap_ID

# Filtering of sub matrices by primary disease "Head and neck cancer"
expression.HNC = expression[ , which(colnames(expression) %in% ID)]
copynumber.HNC = copynumber[ , which(colnames(copynumber) %in% ID)]
kd.ceres.HNC = kd.ceres[ , which(colnames(kd.ceres) %in% ID)]
kd.prob.HNC = kd.prob[ , which(colnames(kd.prob) %in% ID)]
mutation.HNC = mutation[ID]
```

## Expression analysis


### Checking for NAs
```{r 1_expression_NA}
sum(is.na(expression) == TRUE)
```
Result: There are no NAs in the expression data.

### Examine expression values

Create a reference group of expression data
```{r 1_expression_values1}
'%!in%' = function(x,y)!('%in%'(x,y)) # Define function "is not in"

expression.reference = expression[ , which(colnames(expression) %!in% ID)]
```
and calculate their mean.
```{r 1_expression_values2}
mean.exp.reference = apply(expression.reference, 1, mean)
mean.exp.HNC = apply(expression.HNC, 1, mean)
```
Firstly, we want to check if the gene expressions of the HNC samples and the reference group are normally distributed.
```{r 1_expression_values3}
HNC = data.frame(expression_values = mean.exp.HNC, sample = "HNC")
Reference = data.frame(expression_values = mean.exp.reference, sample = "Reference")
mean.expression = rbind(Reference, HNC)

ggqqplot(mean.expression, x = "expression_values",
   color = "sample",
   palette = c("#FC4E07", "#0073C2FF"), # Red and blue
   ggtheme = theme_pubclean())
```

Result: Gene espression is neither in HNC samples nor in reference samples normally distributed.

Then we compare HNC and reference group gene expression using a statistical test. A Wilcoxon rank sum test must be applied because the expression is not normally distributed.
```{r 1_expression_values4}
wilcox.test(mean.exp.HNC, mean.exp.reference)
```
Result: Mean gene expression differs between HNC and reference group samples significantly.


Next we check if the gene expression differs whether a gene has a deleterious mutation or not. AS an example, we compare the mean TP53 gene expression of all samples with and without deleterious TP53 mutation.
```{r 1_expression_values5}
# Get the ID of samples whith and without deleterious mutation
TP53.mut.ID = lapply(1:length(mutation), function(a) {
  dat_picker = mutation[[a]]
  dat_picker = dat_picker[which(dat_picker$isDeleterious == TRUE),]
  out = ifelse("TP53" %in% dat_picker$Hugo_Symbol, a, NA) # Filter all IDs which have a deleterious mutation of TP53
    return(out)
  })

TP53.not_mut.ID = grep("NA", TP53.mut.ID) # ID of samples with no TP53 mutation
TP53.mut.ID = as.integer(TP53.mut.ID[is.na(TP53.mut.ID) == FALSE]) # ID of samples with TP53 mutation

# Create two vectors of expression values
exp.TP53.mut = as.numeric(expression["TP53", TP53.mut.ID]) # Expression of TP53 deleterious mutated samples
exp.TP53.not_mut = as.numeric(expression["TP53", TP53.not_mut.ID]) # Expression of TP53 not deleterious mutated samples
```
Compare the expression values by applying Wilcoxon rank sum test.
```{r 1_expression_values6}
wilcox.test(exp.TP53.mut , exp.TP53.not_mut)
```
Result: Gene expression of TP53 as an example gene varies significantly whether the samples has or has no deleterious TP53 mutation.

At last, we plot a histogram to check how the expression values are distributed.
```{r 1_expression_values7}
gghistogram(as.data.frame(mean.exp.HNC),
            x = "mean.exp.HNC",
            xlab = "expression value",
            bins = 60,
            fill = "#0073C2FF",
            color = "#0073C2FF",
            add = "mean",
            rug = TRUE)
```


Result: The most genes have expression values around 0.



### Plot the 20 most under- and overexpressed genes of HNC samples.
For this we need to normalize the expression data from HNC samples
```{r 1_expression_plot1}
expr.HNC.norm = as.data.frame(apply(expression.HNC, 2, function(x) {
  x - mean.exp.reference
}))
```
and calculate the mean of the normalesid expression values.
```{r 1_expression_plot2}
mean.expr.HNC.norm = as.data.frame(apply(expr.HNC.norm, 1, mean))
```

Then create a dataframe with needed information for the barplot
```{r 1_expression_plot3}
barplot.data = data.frame(Genes=rownames(expr.HNC.norm),
                          Values=mean.expr.HNC.norm)
names(barplot.data) = c("Genes", "Values")
barplot.data$Group = ifelse(barplot.data$Values>0,"overexpressed","underexpressed")
barplot.data = barplot.data[order(barplot.data$Values),]
barplot.data = barplot.data[c(1:19, (nrow(barplot.data)-20):nrow(barplot.data)),]
```
and plot this dataframe.
```{r 1_expression_plot4}
ggplot(barplot.data,aes(x=Genes,y=Values,fill=Group)) +
  ylab("Normalised Expression Values") +
  geom_bar(stat="identity") +
  coord_flip() +
  theme(axis.text.y = element_text(size=6))
```

### Cleanup of the enviroment
```{r 1_expression_cleanup}
rm(HNC, Reference, mean.expression, TP53.mut.ID, TP53.not_mut.ID, exp.TP53.mut, exp.TP53.not_mut, mean.expr.HNC.norm, barplot.data, mean.exp.HNC, mean.exp.reference, expression.reference)
```

## Copynumber Alteration
### Analysis of NA values

Examination of NA values in the copynumber.HNC data
```{r 1_copynumber_NA1}
# Sum up all NAs in each row
NA.rows = apply(copynumber.HNC,1, function(x) {
          sum(is.na(x))
})
# Define all rows cotaining missing values
NA.rows = which( NA.rows > 0)
length(NA.rows)
```
Only 107 out of 23299 gens have NA values and are therefore deleted from the copynumber.HNC dataframe
```{r 1_copynumber_NA2}
copynumber.HNC = copynumber.HNC[-NA.rows,]
dim(copynumber.HNC)
```
Creating a reference data and examination of its NA values
```{r 1_copynumber_NA3}
copynumber.reference = copynumber[,which(colnames(copynumber) %!in% ID)]
dim(copynumber.reference)
```

```{r 1_copynumber_NA4}
NA.rows.ref = apply(copynumber.reference,1, function(x) {
          sum(is.na(x))
})
NA.rows.ref = which( NA.rows.ref > 0)
length(NA.rows.ref)
```

```{r 1_copynumber_NA5}
summary(NA.rows == NA.rows.ref)
```
Genes with NA values are the same for the HNC samples and all the other samples. Therefore, they can be deleted in the reference data as well.

```{r 1_copynumber_NA6}
copynumber.reference = copynumber.reference[-NA.rows.ref,]
copynumber = copynumber[-NA.rows.ref,]
dim(copynumber.reference)
dim(copynumber)
```
### Normalisation of the copynumber values

For the HNC normalisation we will use the mean CN value per gen of the reference data.

```{r 1_copynumber_normalisation1}
copynumber.ref.mean = apply(copynumber.reference,1, mean)
copynumber.HNC.mean = apply(copynumber.HNC ,1, mean)
```

Creating a dataframe of all copynumber values. The values are normalized to the mean copynumbers of the reference data.
```{r 1_copynumber_normalisation2}
cna.HNC.norm = as.data.frame(apply(copynumber.HNC, 2, function(x) {
  x - copynumber.ref.mean
}))
```

Creating a dataframe of HNC copynumber values. The values are normalized to the mean copynumbers of the reference data. For further analysing the dataframe is ordered in a decreasing manner.
```{r  1_copynumber_normalisation3}
Values = copynumber.HNC.mean - copynumber.ref.mean
copynumber.HNC.norm = data.frame(values = sort(Values, decreasing = TRUE), genes = row.names(copynumber.HNC))
copynumber.HNC.norm$Group = ifelse(copynumber.HNC.norm$values > 0,"high CN","low CN")
```

Plotting genes with the highest and lowest copynumbers.
```{r  1_copynumber_plot}
ggplot(copynumber.HNC.norm[c(1:20,23172:23192),],aes(x=genes,y=values,fill=Group)) +
  ylab("Normalised CNA Values") +
  geom_bar(stat="identity") +
  coord_flip() +
  theme(axis.text.y = element_text(size=6))
```


### Cleanup of the environment
```{r 1_copynumber_cleanup}
rm(NA.rows, NA.rows.ref, copynumber.HNC.norm, copynumber.HNC.mean, copynumber.ref.mean, copynumber.reference, Values)
```

## Mutation

### Find Mutations with the highest frequencies

Melt all mutation matrices together and find most often mutated genes over all samples
```{r 1_muation_frequency1}
all_mutations = do.call(rbind,mutation)
all_mutated_genes = table(all_mutations$Hugo_Symbol)
all_mutated_genes_df = as.data.frame(all_mutated_genes)
ID_all_highest_frequencies = head(order(all_mutated_genes_df[["Freq"]], decreasing = TRUE), 30)
all_mutated_genes_df_highest_30 = all_mutated_genes_df[which(rownames(all_mutated_genes_df) %in% ID_all_highest_frequencies), ]
ID_all_highest_30_frequencies = order(all_mutated_genes_df_highest_30["Freq"], decreasing = TRUE) 
all_mutated_genes_df_highest_30_ordered = all_mutated_genes_df_highest_30[ID_all_highest_30_frequencies, ]
rownames(all_mutated_genes_df_highest_30_ordered) = 1:30
colnames_ordered = c("Gene", "Freq")
colnames(all_mutated_genes_df_highest_30_ordered) = colnames_ordered
```

Melt only HNC sample mutation matrices together and find most often mutated genes 
```{r  1_muation_frequency2}
HNC_mutations = do.call(rbind, mutation.HNC)
HNC_mutated_genes = table(HNC_mutations$Hugo_Symbol)
HNC_mutated_genes_df = as.data.frame(HNC_mutated_genes)
ID_HNC_highest_frequencies = head(order(HNC_mutated_genes_df[["Freq"]], decreasing = TRUE), 27)  
HNC_mutated_genes_df_highest_ordered = HNC_mutated_genes_df[ID_HNC_highest_frequencies, ]
rownames(HNC_mutated_genes_df_highest_ordered) = 1:27
colnames(HNC_mutated_genes_df_highest_ordered) = colnames_ordered
```

### Plotting mutation frequencies of all samples and of HNC samples

Plot mutations in all samples
```{r  1_muation_frequency3, fig.height = 7}
ggplot(data = all_mutated_genes_df_highest_30_ordered, aes(x=Gene, y=Freq)) +
  geom_bar(stat = "identity", width = 0.5, fill="steelblue") +
  geom_text(aes(label=Freq), vjust=-0.3, size=2.5) +
  theme_grey() + coord_flip()
```

Plot mutations in HNC samples
```{r  1_muation_frequency4, fig.height = 7}
ggplot(data = HNC_mutated_genes_df_highest_ordered, aes(x=Gene, y=Freq)) +
  geom_bar(stat = "identity", width = 0.5, fill="steelblue") +
  geom_text(aes(label=Freq), vjust=-0.3, size=3.5) +
  theme_grey() +
  coord_flip()
```



### Clean mutation from unnecessary data

Due to the needed conditions in the following "Daisy-tests" we now clean the mutation data and extract all "isDeleterious" mutations, since they are essential for the survival or death of a cell. In this way, we later are able to find our genes of interest for the SL more easily.

```{r 1_muation_cleanmutation}
'mutation.clean' = function(data){
  cleaned_data = lapply(1:length(data), function(a) {
    dat_picker = data[[a]]
    dat_picker = dat_picker[, c("Hugo_Symbol", "isDeleterious")]
    dat_picker = dat_picker[which(dat_picker$isDeleterious == TRUE),]
    return(dat_picker)
  })
  names(cleaned_data) = names(data)
  return(cleaned_data)
}
mutation = mutation.clean(mutation)
mutation.HNC = mutation.clean(mutation.HNC)
head(mutation.HNC[[1]])
```

### Cleanup of the enviroment
```{r 1_muation_cleanup}
rm(all_mutations, all_mutated_genes, all_mutated_genes_df, ID_all_highest_30_frequencies, ID_all_highest_frequencies, all_mutated_genes_df_highest_30, all_mutated_genes_df_highest_30_ordered, colnames_ordered, HNC_mutations, HNC_mutated_genes, HNC_mutated_genes_df, ID_HNC_highest_frequencies, HNC_mutated_genes_df_highest_ordered)
```

## Knockdown

### Checking for NAs and range in HNC patients
```{r 1_knockdown_NA}
sum(is.na(kd.ceres.HNC) == TRUE) # NAs
range(kd.ceres.HNC)# Range of data
```

### Examine knockdown values
```{r 1_knockdown_values_dist}
# Definition of a compare group
kd.ceres.reference = kd.ceres[ , which(colnames(kd.ceres) %!in% ID)]

# Defining mean of knockdown values from comparegroup and HNC patients
mean.kd.ceres.reference = apply(kd.ceres.reference, 1, mean)
mean.kd.ceres.HNC = apply(kd.ceres.HNC, 1, mean)

# Checking if knockdown values are normally distributed
kd.ceres.HNC.dist = data.frame(kd_values = mean.kd.ceres.HNC, sample = "Knockdown HNC")
kd.ceres.reference.dist = data.frame(kd_values = mean.kd.ceres.reference, sample = "reference HNC")
mean.kd.ceres.dist = rbind(kd.ceres.reference.dist, kd.ceres.HNC.dist)

ggqqplot(mean.kd.ceres.dist, x = "kd_values",
   color = "sample",
   palette = c("#FC4E07", "#0073C2FF"),
   ggtheme = theme_grey())



```

Result: kd.ceres values are not normal distributed

Checking the distribution for knockdown values
```{r 1_knockdown_values2}
gghistogram(kd.ceres.HNC.dist, x = "kd_values", xlab = "knockdown values", bins = 60,
            fill = "#0073C2FF", color = "#0073C2FF",
            add = "mean", rug = TRUE)+theme_grey()
```


To check if  there are more essential genes in HNC, the means of HNC patients and the reference group were compared.
```{r 1_knockdown_values1}
# Are there genes that tend to be more essential in HNC?
esgene1 = kd.ceres.HNC[which(rowMeans(kd.ceres.HNC)< rowMeans(kd.ceres.reference)),]
# Sort essential genes
esgene1= esgene1[order(rowMeans(esgene1)),]
```

### Example EGFR
Checking the summary of an example gene
```{r 1_knockdown_EGFR}
# Transposition of dataframe esgene1
esgeneT = as.data.frame(t(esgene1))
summary(esgeneT$EGFR)
```

### Boxplot of 20 generandom genes
```{r 1_knockdown_boxplot}
# Boxplot of 20 of most significiant genes according to knockdown analysis
boxplot(sample(esgeneT,20, replace = FALSE), xlab = "gene", horizontal =T, main="Knockdown values of 20 random genes",
        xlab="genes",
        ylab="Knockdown values",
        col="blue",
        border="brown",
        outline = TRUE,
        notch = TRUE)
abline(col = c("blue", "red", "black", "orange"),
        lty = 2)
```




### Applying Wilcoxon rank sum test because knockdown values are not normally distributed
To check if the HNC knockdown values differ from the compare group, a wilcoxon test is executed.
```{r 1_knockdown_Wilcox}
wilcox.test(mean.kd.ceres.HNC, mean.kd.ceres.reference)
```
The test shows, that ther isn`t a significiant difference between HNC patients and the reference group. Due  to the fact, that knocking down of essential genes has the same effect in healthy cells, than in tumorous cells.




### Cleanup of the enviroment
```{r 1_knockdown_cleanup}
rm(kd.ceres.HNC.dist, kd.ceres.reference, kd.ceres.reference.dist, mean.kd.ceres.HNC, mean.kd.ceres.reference, mean.kd.ceres.dist, esgene1, esgeneT)
```


# 2. Identify genes of interest

## k-means clustering of CNA and expression data with normalized values(-reference) for SDL GOI
To find potential genes for SDL pair detection, clustering through k-means was executed. 
```{r 1_kmeans1}
km.genes = Reduce(intersect, list(rownames(expression.HNC), rownames(copynumber.HNC))) # Intersect set of expression and CNA

# Create data rame with expression and CNA values
km.expression = expr.HNC.norm[km.genes,]
km.copynumber = cna.HNC.norm[km.genes,]
km.data = lapply(1:length(ID), function(x) {
  out = data.frame(genes =km.genes, expression = km.expression[,x], copynumber = km.copynumber[,x])
  return (out)
})
# Combine rows for k mean clustering
comb.ex.cna = do.call(rbind, km.data)
comb.ex.cna = comb.ex.cna[which(comb.ex.cna$copynumber >= 1 & comb.ex.cna$expression >=quantile(comb.ex.cna$expression,0.95)),]

# Plotting of normalized expression valuess against CNA data for a short overview. 
ggplot(comb.ex.cna[, 2:3],
       aes(x = expression, y = copynumber, color = "smooth")) +
  geom_point()
```

To check the perfect ammount of clusters in k-means, an ellbow test was implemented
```{r 1_ellbow method}
# Ellbow method to find optimal ammount of clusters
emp = vector() #create an empty vector
for (i in 1:10) emp[i] = sum(kmeans(comb.ex.cna[2:3], i)$withinss) # Calculate the sum within squared values for 10 clusters
emp # Look at the sum within squares for 10 clusters

# Plotting of Ellbow method
plot(1:10,
     emp,
     type = 'b',
     main = paste('The Elbow Method'),
     xlab = 'Number of clusters',
     ylab = 'EMP') 
```


Result: The ellbow test shows that 3 clusters are sufficient.


K-means were executed and plotted. Afterwards the potential SDL candidates were identified through higher expression values.
```{r 1_kmeansclustering}
# Fitting K-Means to the dataset
kmeans = kmeans(x = comb.ex.cna[,2:3], centers = 3,iter.max = 1000, nstart = 1) # See elbow method (k = 3) 
y_kmeans = kmeans$cluster 

# Visualising the clusters
clusplot(comb.ex.cna,
         y_kmeans,
         lines = 0,
         shade = TRUE,
         color = TRUE,
         labels = 4,
         plotchar = FALSE,
         span = TRUE,
         stand = FALSE,
         cex =0.5,
         main = paste('Clusters of Genes'),
         xlab = 'Expression',
         ylab = 'CNA')

comb.ex.cna = cbind(comb.ex.cna, y_kmeans)# Combine kmeans with genes
# Sort comb.ex.cna data decresing for selecting adequate number of cluster
comb.ex.cna = comb.ex.cna[order(comb.ex.cna$expression,decreasing =TRUE),]

# Filtering of the most expressed and alterated genes
goi.sdl = comb.ex.cna[which(comb.ex.cna$y_kmeans == comb.ex.cna[1,4]),]

# Sort dataframe 
goi.sdl = goi.sdl[order(goi.sdl$expression,decreasing=TRUE),]
kable(goi.sdl[1:5,])

goi.SDL = as.character(goi.sdl$genes[1:5])
rm(emp, i, km.genes, y_kmeans, kmeans, km.copynumber, km.data, km.expression, comb.ex.cna) # Clean enviroment
```

## Investigate high frequencies of deleterious mutations SL GOI

Create a dataframe with data for the heatmap.
```{r 2_SLgoi1, fig.width=8, fig.height=10}
mutation.HNC.df = do.call(rbind, mutation.HNC) # All mutation data of HNC samples in one dataframe
heatmap.genes = as.data.frame(table(mutation.HNC.df$Hugo_Symbol)) # Dataframe with all mutated genes in HNC samples just once

heatmap.data = as.data.frame(sapply(1:(length(ID)), function(a) {
  out = ifelse(heatmap.genes$Var1 %in% mutation.HNC[[a]]$Hugo_Symbol, 1, 0) # Per HNC sample: every gene which is mutated gets a 1, otherwise a 0
  return(out)
}))

# Define row and column names
rownames(heatmap.data) = heatmap.genes$Var1
colnames(heatmap.data) = ID

# Order from high to low frequency
heatmap.data$sum = apply(heatmap.data, 1, sum)
heatmap.data = heatmap.data[order(-heatmap.data$sum), 1:27] 

# Heatmap of the most frequently deleterious mutated genes in HNC samples
heatmap(data.matrix(heatmap.data)[1:40,],
        Rowv=NA,
        Colv=NA,
        col = c("lightgrey", "tomato2"),
        scale="column",
        cexRow = 0.8,
        cexCol = 0.8,
        main = "Most frequently deleterious mutated genes in HNC samples")
```

Result: TP53, FAT1, CDKN2A, KRT3 and CASP8 are the 5 most frequently deleterious mutated genes in our HNC samples

According to Leemans et al. (2018) these are frequent mutations in HNC:
![](images/frequent_mutations_HNC.png)

Leemans, C. R. et al. (2018). The molecular landscape of head and neck cancer. Nat. Rev. Cancer 18, 269-282.


Compare our SL GOI with genes from literature.
```{r 2_SLgoi2}
# create dataframe with goi from literature
goi.lit = data.frame(Gene = c("CDKN2A", "TP53", "CCND1", "EGFR", "PIK3CA", "PTEN", "FAT1", "AJUBA", "NOTCH1", "KMT2D", "NSD1"),
                     "Mutation frequency" = c(22, 72, 0.6, 4, 18, 3, 23, 7, 18, 16, 12),
                     "CNA frequency" = c(32, 1.4, 25, 11, 21, 4, 8, 1, 4, 0.4, 0.8)) 

heatmap_position = sapply(1:nrow(goi.lit), function(a) { # Search for the position of goi.lit in mutated genes of HNC samples
  position = which(rownames(heatmap.data) == goi.lit$Gene[a])
  if(length(position) == 0) {position = NA} # If gene is not part of the genes mutated in HNC samples its position is replaced with NA
  return(position)
})

goi.lit$"Heatmap position" = heatmap_position # Add heatmap position to goi.lit
rownames(goi.lit) = goi.lit$Gene
goi.lit$Gene = NULL
goi.lit = goi.lit[order(goi.lit$"Heatmap position"),]
kable(goi.lit) # Show a table of goi.lit
```

Because our most frequent mutated genes almost aproximately match with frequent mutations from literature we choose the 5 genes with most frequent mutations in HNC samples.
```{r 2_SLgoi3}
goi.SL = rownames(heatmap.data)[1:5]
goi.SL
```

Clean up of the enviroment
```{r 2_SLgoi_cleanup}
rm(mutation.HNC.df, heatmap.genes, heatmap.data, heatmap_position)
```

# 3. Find SL/SDL partner

## SL/SDL partner search following the daisy model

To examine gene pairs A and B which fulfill the criteria of SoF and functional examination we performe a Wilcoxon rank sum test on copynumber or CERES knockdown data. We have 5 inactive genes (goi.SL) and 5 overactive genes (goi.SDL) which are defined as genes A. The Wilcoxon rank sum test now returns all genes B which pass the test in a significant manner (p<0.05). 
```{r 3_Wilcox}
'Daisy.Wilcox' = function(input_genes,input_data, inactive_overactive, less_greater){
  Daisy_Wilcox = lapply(1:length(input_genes), function(m) {
  goi = input_genes[m] # Set 1 of 5 goi
  # Depending on SL or SDL partner search gene B needs to be inactive (SL) or overactive (SDL)
  if(inactive_overactive == 1) { # inactive_overactive == 1 chooses overactive
    mean.exp.goi = mean(t(expression[goi,]))
    exp.goi.norm = expression[goi,] - mean.exp.goi # Normalised expression values of goi
    mut_overa.ID = lapply(1:ncol(expression), function(a) {
    out = if(exp.goi.norm[goi, a] > 0 & copynumber[goi,a] > 0.3) {a} else {NA} # Filter all IDs which are overactive: overexpressed and CNA > 0,3
    return(out)
    })
  } else { # inactive_overactive == 0 chooses inactive
    mut_overa.ID = lapply(1:length(mutation), function(a) {
    out = ifelse(goi %in% mutation[[a]]$Hugo_Symbol, a, NA) # Filter all IDs which have a mutation of goi
    return(out)
    })
  }
  
  not_mut_overa.ID = grep("NA", mut_overa.ID) # ID of samples which have NO inactivity/overactivity of goi
  mut_overa.ID = as.integer(mut_overa.ID[is.na(mut_overa.ID) == FALSE]) # ID of samples which HAVE inactivity/overactivity of goi

  p.value = sapply(1:nrow(input_data), function(b) {
    mut_overa.data = t(input_data[b, mut_overa.ID])
    not_mut_overa.data = t(input_data[b, not_mut_overa.ID])
    if (less_greater == 1) {
      p = wilcox.test(mut_overa.data, not_mut_overa.data, alternative = "greater")$p.value # One sided (greater) Wilcoxon Sum Rank Test 
    } else {
      p = wilcox.test(mut_overa.data, not_mut_overa.data, alternative = "less")$p.value # One sided (greater) Wilcoxon Sum Rank Test
    }
    
  })

  out = data.frame(genes = rownames(input_data), p_value = p.value)
  out = out[which(out$p_value < 0.05),]
  return(out)
  })
  names(Daisy_Wilcox) = input_genes
  return(Daisy_Wilcox)
}
```

To examine gene pairs A and B which fulfill the criteria of gene co expresssion we performe a Spearman correlation test on the expression data. We have 5 inactive genes (goi.SL) and 5 overactive genes (goi.SDL) which are defined as genes A The correlation test now returns all genes B that correlate to gene A in a significant manner (p<0.05).
```{r 3_Spearman}
'Daisy.Spearman' = function(input_genes){
  Daisy_Spearman = lapply(1:length(input_genes), function(m) { # Build up a list with the 5 goi; lapply: goes through the code for each gene A
  goi = input_genes[m]

  p.value = sapply(1:nrow(expression), function(a){  # Creation of a list with the length of the expression data, for the reacent goi, go through every gene and calculate cor.test
    expression.goi =t(expression[goi,])           # Variable containing expressiondata of the goi (gene A)
    expression.GeneB =t(expression[a,])           # Variable containing all other genes (gene B)
    p = cor.test(expression.goi,expression.GeneB, alternative = "greater", method = "spearman", exact = FALSE)$p.value # One sided spearman correlation test  
  })
  
  # Return a dataframe with the columns genes(HugoSymbols) and p_values (p.values)
  out = data.frame(genes = rownames(expression), p_value = p.value)
  out = out[which(out$p_value < 0.05),] # Filter for significant p.values
  out = out[which(out$genes != goi),]   # Select onl these wich are not the same gene as the goi (would be a corr of 1)
  return(out)
  })
  names(Daisy_Spearman) = input_genes
  return(Daisy_Spearman)
}
```


Both functions return a list, which contains the five genes of interest, each containing a dataframe with all genes examined as potential SL/SDL partners plus their calculated p-values.


### SL-parter
SoF
```{r 3_SL_SoF}
SL.SoF = Daisy.Wilcox(goi.SL, copynumber, inactive_overactive = 0, less_greater = 1) # SoF, inactive, one sided Wilcoxon rank test, alternative = "greater"
head(SL.SoF[[1]]) # Example of SL SoF for first GOI (TP53)
```
Functional examination
```{r 3_SL_functional_examination}
SL.functional.examination = Daisy.Wilcox(goi.SL, kd.ceres, inactive_overactive = 0, less_greater = 0) # Functional examination, inactive, one sided Wilcoxon rank test, alternative = "less"
head(SL.functional.examination[[1]]) # Example of SL functional examination for first GOI (TP53)
```
Gene coexpression
```{r 3_SL_coexpression}
SL.coexpression = Daisy.Spearman(goi.SL)
head(SL.coexpression[[1]]) # Example of SL coexpression for first GOI (TP53)
```

### SDL-parter
SoF
```{r 3_SDL_SoF}
SDL.SoF = Daisy.Wilcox(goi.SDL, copynumber, inactive_overactive = 1, less_greater = 1) # SoF, overactive, one sided Wilcoxon rank test, alternative = "greater"
```
Functional examination
```{r 3_SDL_functional_examination}
SDL.functional.examination = Daisy.Wilcox(goi.SDL, kd.ceres, inactive_overactive = 1, less_greater = 0) # Functional examination, overactive, one sided Wilcoxon rank test, alternative = "less"
```
Gene coexpression
```{r 3_SDL_coexpression}
SDL.coexpression = Daisy.Spearman(goi.SDL)
```

## Converging the different SL and SDL sets

Define function to converge SL/SDL sets.
```{r 3_partner}
'partner' = function(input_genes, SoF, functional.examination, coexpression){
  partner = lapply(1:length(input_genes), function(a) {
    dat_picker.SoF = SoF[[a]]
    dat_picker.functional_examination = functional.examination[[a]]
    dat_picker.coexpression = coexpression[[a]]
    partnergenes = Reduce(intersect, list(dat_picker.SoF$genes, dat_picker.functional_examination$genes, dat_picker.coexpression$genes)) # Intersect of genes from all three tests
    out = data.frame(genes = partnergenes, # Column with reduced genes
                     SoF = dat_picker.SoF[which(dat_picker.SoF$genes %in% partnergenes),"p_value"], # Column with p value from SoF
                     functional_examination = dat_picker.functional_examination[which(dat_picker.functional_examination$genes %in% partnergenes),"p_value"], # Column with p value from functional examination
                     coexpression = dat_picker.coexpression[which(dat_picker.coexpression$genes %in% partnergenes),"p_value"]) # Column with p value from coexpression
    return(out)
  })
  names(partner) = input_genes
  return(partner)
}
```
Converge different sets.
```{r 3_converging}
SL.partner = partner(goi.SL, SL.SoF, SL.functional.examination, SL.coexpression)
SDL.partner = partner(goi.SDL, SDL.SoF, SDL.functional.examination, SDL.coexpression)
kable(data.frame("SL genes" = names(SL.partner),
           "SL number of partner" = sapply(1:length(SL.partner), function(a){nrow(SL.partner[[a]])}),
           "SDL genes" = names(SDL.partner),
           "SDL number of partner" = sapply(1:length(SDL.partner), function(a){nrow(SDL.partner[[a]])})
           ))
```

## Plotting networks of the Interactions 

Creation of a function for transforming given data into a format iGraph can work with and plotting of the network
```{r 3_network}
'network' = function(X.partner,width,node.color,frame.color,node.size,Titel,label,GOI){ # (SL/SDL.partner,number,string,string,number,string,NA oder names(plot))
  
  color.vector = c("darkred", "darkgreen", "turquoise", "yellow", "orange") # Define colours
  # transform data into a dataframe with 3 colums for each GOI  
  edgelist = lapply(1:length(X.partner), function(a){
    dat_picker = X.partner[[a]]
    edge.list = data.frame(Gene.A = names(X.partner)[a], Gene.B = dat_picker$genes, colours = color.vector[a]) # 3 columns
  })
  edge.list = do.call(rbind, edgelist) # Combine all goi-dataframes to one.

  edge.list$colours = as.character(edge.list$colours) # After the lapply, column "colours" has class 'factor'. For the plottingfunction it must be character 
  
  net = graph_from_data_frame(edge.list, directed = T) # Tranform the dataframe into an iGraph object
  layout1 = layout_with_kk(net)                        # Given layout

  # Plotting parameters are defined. vertex= Genes edges = interactions 
  plot(net, layout = layout1, rescale = T,
       ylim = c(-0.9,1),
       xlim = c(-0.1,-0.1),
       edge.color = edge.list$colours,
       edge.width = width,
       edge.arrow.mode = 0,
       vertex.color = node.color,
       vertex.frame.color = frame.color,
       vertex.size = node.size,
       vertex.label.font = 2,
       vertex.label.color = "black",
       vertex.label = label,
       margin = 0.1)

  # Adding a legend to the plot
  legend (x = 1.2,
          y = 1, GOI,
          fill = c("darkred", "darkgreen", "turquoise", "yellow", "orange"))

  # Add titel to the graph
  title(Titel,cex.main=3,col.main="black ")

}

```


Creating a networkplot for the SL-partner
```{r 3_SL_network, fig.height = 7, fig.width = 10}
network(SL.partner,2,"grey","black",3,"Network of SL interaction", NA, goi.SL )
```

Creating a network for the SDL-partner
```{r 3_SDL_network, fig.height = 7, fig.width = 10}
network(SDL.partner,2,"grey","black",3,"Network of SDL interaction", NA, goi.SDL )
```

Because there are to many SL/SDL partner to plot a network we reduce SL/SDL partner to the most significants.
To do so, we reduce the number of partner genes for better plotting without removing genes which are connected to more than one GOI.
```{r 3_reduce_partner}
'reduce.partner' = function(list){ 
  reduced_partner = lapply(1:length(list), function(a){ # Go through every element of SL/SDL partner
    dat_picker = list[[a]]
    
    if (nrow(dat_picker) > 20) { # (1) If length of dat_picker is larger than 20 reduce to the 20 most significant plus the genes we want to keep
      
      dat_picker$order = apply(dat_picker[,2:4], 1, mean) # Create an extra column with the mean p value of all 3 tests
      ordered_data = dat_picker[order(dat_picker$order),][,1:4] # Order the partner genes after this mean value from most to least significant p value
      
      gene_intersect = lapply(1:length(list), function(b){ 
          as.list(Reduce(intersect, list(dat_picker$genes), list[[b]]$genes)) # Search for genes that are partner for more than one GOI
      })
      gene_intersect[a] = NULL # Remove intersect of the GOI partner genes with itself
      keep_genes = c(gene_intersect[[1]], gene_intersect[[2]], gene_intersect[[3]], gene_intersect[[4]]) # Combine all the genes in a list
      position = sapply(1:length(keep_genes), function(c){
        which(as.character(ordered_data$genes) == keep_genes[c])
      })
      position = position[which(position > 20)] # Partner genes that are already in the first 20 genes don´t need to be chosen
      
      if(length(position) > 3) {position = position[1:3]} # If there are still more than 3 extra genes only choose the first 5
      out = ordered_data[c(1:20, position),]
      return(out) # Return reduced data
    } else {
      return(ordered_data) # (2) If length of dat_picker is smaller than 20 return data unreduced 
    }
  })
  names(reduced_partner) = names(list)
  return(reduced_partner)
}
```

Reduce SL.parter/SDL.partner to the most significant
```{r  3_reduction}
SL.partner.reduced = reduce.partner(SL.partner)
SDL.partner.reduced = reduce.partner(SDL.partner)

kable(data.frame("SL genes" = names(SL.partner),
           "SL partner" = sapply(1:length(SL.partner.reduced), function(a){nrow(SL.partner.reduced[[a]])}),
           "SDL genes" = names(SDL.partner),
           "SDL partner" = sapply(1:length(SDL.partner.reduced), function(a){nrow(SDL.partner.reduced[[a]])})
           ))
```

Now the number of SL/SDL partner is much better to plot.


Plotting SL/SDL partner network with reduced number of partner

SL interaction plot with reduced partners
```{r 3_SL_network_reduced, fig.height = 12, fig.width = 15.3}
network(SL.partner.reduced,4,"grey","grey",12,"Network of SL interaction (reduced)", names(plot), goi.SL)
```

SDL interaction plot with reduced partners
```{r 3_SDL_network_reduced, fig.height = 12, fig.width = 15}
network(SDL.partner.reduced,4,"grey","grey",12,"Network of SDL interaction (reduced)", names(plot),goi.SDL)
```

# 4. Mutation prediction via logistical regression

## Prepare data for regression model
```{r 4_df}
# Reduce all genes to them of which we have expression, copynumber and knockdown data.
regression.genes = Reduce(intersect, list(rownames(expression), rownames(copynumber), rownames(kd.ceres)))

# Create a dataframe with expression, copynumber, knockdown and mutation data from a HNC sample.
regression.data = lapply(1:length(ID), function(a){
  
  regression.mutation = sapply(1:length(regression.genes), function(b){
    ifelse(regression.genes[b] %in% mutation.HNC[[a]]$Hugo_Symbol, TRUE, FALSE)
  })

  regression.data = data.frame("genes" = paste(regression.genes, ID[a], sep = "_"),
                               "expression" = expression.HNC[regression.genes, a],
                               "copynumber" = copynumber.HNC[regression.genes, a],
                               "kockdown" = kd.ceres.HNC[regression.genes, a],
                               "mutation" = regression.mutation)
})

# Bind these 27 dataframes to one dataframe
regression.data = do.call(rbind, regression.data)

rm(regression.genes)
dim(regression.data)
head(regression.data)
```

Reformat the data because strings can not be an input for a machine learning model
```{r 4_factor_mutation}
regression.data$mutation = factor(regression.data$mutation, levels = c("FALSE", "TRUE"))
head(regression.data)
```

Split the data into train and test-data
```{r 4_split_data}
inTrain = createDataPartition(y = regression.data$mutation, p = .75, list = FALSE)
train.set = regression.data[inTrain,] # Only get training data
rownames(train.set) = train.set$genes # Reformat the rownames
train.set = train.set[,2:ncol(train.set)] # Get rid of the gene names becaue they are now the rownames
head(train.set) # Check the data

test.set = regression.data[-inTrain,]
rownames(test.set) = test.set$genes
test.set = test.set[,2:ncol(test.set)]
head(test.set)
```

## Train the model
```{r 4_train}
lrfit = glm(mutation ~ ., data=train.set,family="binomial") 
lrfit
summary(lrfit)
```

## Evaluate the precision and the recall of the model
```{r 4_test}
pred = predict(lrfit,newdata=test.set,type="response")
hist(pred) # Look at the predictions
```



Devide prediction in tressholds
```{r 4_treshhold}
threshhold_ls = seq(min(pred), max(pred), by=0.001) # Make a thresshold list
threshold_list = lapply(seq_along(threshhold_ls), function(a) table(pred>threshhold_ls[a], test.set$mutation))
```

Calculate the precision values
```{r 4_precision}
results_df = lapply(1:length(threshold_list), function(a) { # Make a df out of the list of lists
  threshold = threshold_list[[a]]
  threshold_value = threshhold_ls[[a]]
  
  df_prec_recall = as.data.frame(list(threshold["FALSE", "FALSE"], threshold["FALSE", "TRUE"], threshold["TRUE", "FALSE"], threshold["TRUE", "TRUE"]))
  df_prec_recall$threshold = threshold_value
  colnames(df_prec_recall) = c("TN", "FN", "FP", "TP", "Thresh")
  return(df_prec_recall)
})

results_df = rbindlist(results_df) # Bind all the lists together
recall = apply(results_df, 1, function(x){ x[["TP"]]/(x[["TP"]]+x[["FN"]])}) # Calculate the recall
precision = apply(results_df, 1, function(x){ x[["TP"]]/(x[["TP"]]+x[["FP"]])}) # Calculate the precision
results_df$recall = recall # Bind recall to the data
results_df$precision = precision # Bind precision to the data
head(results_df) # Look at the data
```

Plot the data
```{r 4_plot}
ggplot(results_df, aes(recall,precision)) + 
  geom_point() + 
  geom_line() + 
  ggtitle("Precision/Recall plotting (Log.Reg.)") +
  ylab("Precision") +
  xlab("Recall") +
  theme_bw(base_size = 7) +
  theme(legend.position="bottom",
        legend.direction="horizontal",
        plot.title = element_text(hjust = 0.5),
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        legend.title= element_blank(),
        strip.text.y = element_text(angle = 0))
```


Clean the enviroment
```{r 4_cleanup}
rm(precision, pred, recall, regression.genes, threshhold_ls, inTrain, lrfit, results_df, test.set, threshold_list, train.set)
```

