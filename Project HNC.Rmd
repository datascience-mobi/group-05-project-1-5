---
title: "Project Head and Neck Cancer"
author: "Nils Mechtel, Tobias Hub, Niklas Urbanek, Pascal Poc"
date: "6 Mai 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(ggpubr)
theme_set(theme_pubr())
library(png)
root.dir = dirname(rstudioapi::getSourceEditorContext()$path)
'%!in%' <- function(x,y)!('%in%'(x,y))
library(tidyverse)  # data manipulation
library(cluster)    # clustering algorithms
library(factoextra) # clustering algorithms & visualization
library(rstudioapi)
```

# General Introduction
Head and neck cancer is defined as a group of cancers, concerning the mouth, nose and throat. With over 90%, Squamous cell carcinoma is the most common type in HNC patients.With 5.5 million affected people in 2015 it is the seventh most frequent cancer and the ninth most frequent cause of death. (Information required)


![](images/HNC_Kopf.png)
In the century of next generation sequencing, the genome became an interesting target for scientists.Approaches that directly affect important oncogenes often fail due to the fact that these genes play an improtant role in healthy cells.The researchers in our paper investigated synthetic lethality and synthetic dosage letahlity that uses gene interactions to affect tumorous proliferation. Synthetic letahlity is a gene interaction in which single-gene defects
are compatible with cell viability, but the combination of gene effects results in cell death.Synthetic dosage lethality occurs, when the overexpression of one gene is combined with the knockout of another gene.

![](images/Daisy.png)



# 1. Data Cleanup & Descriptive Statistics

## Loading data and defining HNC variables
```{r}
# Load dataset
allDepMapData = readRDS("DepMap19Q1_allData.RDS")

# Creation of sub matrices
expression = allDepMapData[["expression"]]
copynumber = allDepMapData[["copynumber"]]
mutation = allDepMapData[["mutation"]]
kd.ceres = allDepMapData[["kd.ceres"]]
kd.prob = allDepMapData[["kd.prob"]]
annotation = allDepMapData[["annotation"]]
rm(allDepMapData)

# Reducing the samples to head and neck cancer samples
annotation.HNC = annotation[which(annotation$Primary.Disease == "Head and Neck Cancer"), ]
ID = annotation.HNC$DepMap_ID

# Filtering of sub matrices by primary disease "Head and neck cancer"
expression.HNC = expression[ , which(colnames(expression) %in% ID)]
copynumber.HNC = copynumber[ , which(colnames(copynumber) %in% ID)]
kd.ceres.HNC = kd.ceres[ , which(colnames(kd.ceres) %in% ID)]
kd.prob.HNC = kd.prob[ , which(colnames(kd.prob) %in% ID)]
mutation.HNC = mutation[ID]
```

## Expression analysis

### Checking fo NAs
```{r}
sum(is.na(expression) == TRUE)
```

### Examine expression values

Comparing mean gene expression of all samples with just HNC samples.
```{r}
expression.reference = expression[ , -which(colnames(expression) %in% ID)]
mean.exp.reference = apply(expression.reference, 1, mean)
mean.exp.HNC = apply(expression.HNC, 1, mean)
```
Checking if expression is normally distributed
```{r}
HNC = data.frame(expression_values = mean.exp.HNC, sample = "HNC")
reference = data.frame(expression_values = mean.exp.reference, sample = "reference")
mean.expression = rbind(reference, HNC)

ggqqplot(mean.expression, x = "expression_values",
   color = "sample",
   palette = c("#FC4E07", "#0073C2FF"),
   ggtheme = theme_pubclean())

rm(HNC, reference, mean.expression)
```
Result: Gene espression is not normally distributed.

Applying Wilcoxon rank sum test because expression is not normally distributed
```{r}
wilcox.test(mean.exp.HNC, mean.exp.reference)
```
Result: Mean gene expression differs between HNC samples and all samples significantly.

Comparing mean TP53 gene expression of all samples with and without deleterious TP53 mutation
```{r}
mutation.df = do.call(rbind, mutation)
TP53.mut.ID = mutation.df[which(mutation.df$Hugo_Symbol == "TP53" & mutation.df$isDeleterious == TRUE), ]$DepMap_ID
TP53.norm.ID = annotation$DepMap_ID[-which(annotation$DepMap_ID %in% TP53.mut.ID)]
exp.TP53.mut = as.numeric(expression["TP53", TP53.mut.ID])
exp.TP53.norm = as.numeric(expression["TP53", TP53.norm.ID])
```
Applying Wilcoxon rank sum test because expression is not normally distributed
```{r}
wilcox.test(exp.TP53.mut , exp.TP53.norm)
rm(TP53.mut.ID, TP53.norm.ID, exp.TP53.mut, exp.TP53.norm)
```
Result: Gene expression of varies significantly whether the samples has or has no a deleterious TP53 mutation.

Checking how the expression values are distributed
```{r}
expression.values = data.frame(expression_value = mean.exp.HNC)
# density plot
ggdensity(expression.values, x = "expression_value", xlab = "expression value",
          fill = "#0073C2FF", color = "#0073C2FF",
          add = "mean", rug = TRUE)
# histogram
gghistogram(expression.values, x = "expression_value", xlab = "expression value", bins = 60,
            fill = "#0073C2FF", color = "#0073C2FF",
            add = "mean", rug = TRUE)
rm(expression.values)
```
### Normalize expression data from HNC samples
```{r}
expr.HNC.norm = as.data.frame(apply(expression.HNC, 2, function(x) {
  x - mean.exp.reference
}))
```
### Plotting the 25 most under- and overexpressed genes of the first sample
```{r}
mean.expr.HNC.norm = as.data.frame(apply(expr.HNC.norm, 1, mean))
barplot.data = data.frame(Genes=rownames(expr.HNC.norm),Values=mean.expr.HNC.norm)
names(barplot.data) = c("Genes", "Values")
barplot.data$Group<-ifelse(barplot.data$Values>0,"overexpressed","underexpressed")
barplot.data = barplot.data[order(barplot.data$Values),]
barplot.data = barplot.data[c(1:24, (nrow(barplot.data)-25):nrow(barplot.data)),]
ggplot(barplot.data,aes(x=Genes,y=Values,fill=Group))+geom_bar(stat="identity")+coord_flip()
rm(mean.expr.HNC.norm, barplot.data)
```

## Copynumber Alteration
### analysis of NA values

Examination of NA values in the copynumber.HNC data
```{r}
NA.rows = apply(copynumber.HNC,1, function(x) {
          sum(is.na(x))
})
NA.rows = which( NA.rows > 0)
length(NA.rows)
```
Only 107 out of 23299 gens have NA values and are therefore deleted from the copynumber.HNC matrix
```{r}
copynumber.HNC = copynumber.HNC[-NA.rows,]
dim(copynumber.HNC)
```
Creating a reference data and examination of its NA values
```{r}
copynumber.reference = copynumber[,-which(colnames(copynumber) %in% ID)]
dim(copynumber.reference)
```

```{r}
NA.rows.ref = apply(copynumber.reference,1, function(x) {
          sum(is.na(x))
})
NA.rows.ref = which( NA.rows.ref > 0)
length(NA.rows.ref)
```

```{r}
summary(NA.rows == NA.rows.ref)
```
Gens with NA values are the same for the HNC samples compared to all the other samples. Therefore they can be deleted as well in the reference data.

```{r}
copynumber.reference = copynumber.reference[-NA.rows.ref,]
copynumber = copynumber[-NA.rows.ref,]
dim(copynumber.reference)
dim(copynumber)
```
### Normalisation of the copynumber values

For the HNC normalisation we will use the mean CN value per gen of the reference data.

```{r}
copynumber.ref.mean = apply(copynumber.reference,1, mean)

copynumber.HNC.mean = apply(copynumber.HNC ,1, mean)
```

Creating a matrix of HNC copynumber values. The values are normalized to the mean copynumbers of the reference data. For further analysing the matrix is ordered in a decreasing manner.
```{r}
copynumber.HNC.norm = copynumber.HNC.mean - copynumber.ref.mean
copynumber.HNC.norm = copynumber.HNC.norm[order(copynumber.HNC.norm, decreasing = TRUE )]
copynumber.HNC.norm = as.data.frame(copynumber.HNC.norm)
copynumber.HNC.norm$genes = row.names(copynumber.HNC.norm)
```
Creating a dataframe of all copynumber values. The values are normalized to the mean copynumbers of the reference data.
```{r}
cna.HNC.norm = as.data.frame(apply(copynumber.HNC, 2, function(x) {
  x - copynumber.ref.mean
}))
```

Plotting genes with the highest and lowest copynumbers.
```{r}
copynumber.HNC.norm$Group <- ifelse(copynumber.HNC.norm$copynumber.HNC.norm > 0,"high CN","low CN")
ggplot(copynumber.HNC.norm[c(1:20,23172:23192),],aes(x=genes,y=copynumber.HNC.norm,fill=Group))+geom_bar(stat="identity")+coord_flip()
```
### Cleanup of the environment
```{r}
rm(NA.rows, NA.rows.ref, copynumber.HNC.norm)
```

## Mutation

### Find Mutations with the highest frequencies

Melt all mutation matrices together and find most often mutated genes over all samples
```{r}
all_mutations = do.call(rbind,mutation)
all_mutated_genes = table(all_mutations$Hugo_Symbol)
all_mutated_genes_df = as.data.frame(all_mutated_genes)
ID_all_highest_frequencies = head(order(all_mutated_genes_df[["Freq"]], decreasing = TRUE), 30)
all_mutated_genes_df_highest_30 = all_mutated_genes_df[which(rownames(all_mutated_genes_df) %in% ID_all_highest_frequencies), ]
ID_all_highest_30_frequencies = order(all_mutated_genes_df_highest_30["Freq"], decreasing = TRUE) 
all_mutated_genes_df_highest_30_ordered = all_mutated_genes_df_highest_30[ID_all_highest_30_frequencies, ]
rownames(all_mutated_genes_df_highest_30_ordered) = 1:30
colnames_ordered = c("Gene", "Freq")
colnames(all_mutated_genes_df_highest_30_ordered) = colnames_ordered
```

Melt only HNC sample mutation matrices together and find most often mutated genes 
```{r}
HNC_mutations = do.call(rbind, mutation.HNC)
HNC_mutated_genes = table(HNC_mutations$Hugo_Symbol)
HNC_mutated_genes_df = as.data.frame(HNC_mutated_genes)
ID_HNC_highest_frequencies = head(order(HNC_mutated_genes_df[["Freq"]], decreasing = TRUE), 27)  
HNC_mutated_genes_df_highest_ordered = HNC_mutated_genes_df[ID_HNC_highest_frequencies, ]
rownames(HNC_mutated_genes_df_highest_ordered) = 1:27
colnames(HNC_mutated_genes_df_highest_ordered) = colnames_ordered
```

### Plotting mutation frequencies of all samples and of HNC samples

Plot mutations in all samples
```{r}
all_mut_plot = ggplot(data = all_mutated_genes_df_highest_30_ordered, aes(x=Gene, y=Freq)) + geom_bar(stat = "identity", width = 0.5, fill="steelblue") +  geom_text(aes(label=Freq), vjust=-0.3, size=3.5) + theme_minimal()
all_mut_plot
```

Plot mutations in HNC samples
```{r}
HNC_mut_plot = ggplot(data = HNC_mutated_genes_df_highest_ordered, aes(x=Gene, y=Freq)) + geom_bar(stat = "identity", width = 0.5, fill="steelblue") + geom_text(aes(label=Freq), vjust=-0.3, size=3.5) + theme_minimal()
HNC_mut_plot
```

## Knockdown

### Checking fo NAs and range in HNC patients
```{r}
sum(is.na(kd.ceres.HNC) == TRUE) # Range of data
range(kd.ceres.HNC)
```
### Definition of a compare group
```{r}
kd.ceres.reference = kd.ceres[ , -which(colnames(kd.ceres) %in% ID)]

# Comparing mean knockdown data of all samples with just HNC samples
mean.kd.ceres.reference = apply(kd.ceres.reference, 1, mean)
mean.kd.ceres = apply(kd.ceres.HNC, 1, mean)

# Checking if knockdown values are normally distributed
kd.ceres.HNC.dist = data.frame(kd_values = mean.kd.ceres, sample = "Knockdown HNC")
kd.ceres.reference.dist = data.frame(kd_values = mean.kd.ceres.reference, sample = "reference HNC")
mean.kd.ceres.dist = rbind(kd.ceres.reference.dist, kd.ceres.HNC.dist)

ggqqplot(mean.kd.ceres.dist, x = "kd_values",
   color = "sample",
   palette = c("#FC4E07", "#0073C2FF"),
   ggtheme = theme_pubclean())

# Are there genes that tend to be more essential in HNC?
esgene1 = kd.ceres.HNC[-which(rowMeans(kd.ceres.HNC)> rowMeans(kd.ceres.reference)),]
```
result: kd.ceres values are not normal distributed

### Checking the distribution for knockdown values
```{r}
gghistogram(kd.ceres.HNC.dist, x = "kd_values", xlab = "knockdown values", bins = 60,
            fill = "#0073C2FF", color = "#0073C2FF",
            add = "mean", rug = TRUE)
```
### Applying Wilcoxon rank sum test because knockdown values are not normally distributed
```{r}
wilcox.test(mean.kd.ceres, mean.kd.ceres.reference)
```

### Example EGFR
```{r}
# Transposition of matrix esgene1
esgeneT <- as.data.frame(t(esgene1))
summary(esgeneT$EGFR)
```

### Boxplot of 20 genes
```{r}
boxplot(esgeneT[810:830], xlab = "gene", horizontal = F)
abline(col = c("blue", "red", "black", "orange"),
    lty = 2)

rm(esgene1, esgeneT)
```


# 2. Identify genes of interest

## k-means clustering of CNA and expression data with normalized values(-reference)

```{r}
#Remove values, that are either in expression data or CNA data
ID1 = rownames(copynumber.HNC)
expression.norm.plusinCNA = expr.HNC.norm[ which(rownames(expr.HNC.norm) %in% ID1),]
rm(ID1)

ID2 = rownames(expression.norm.plusinCNA)
CNA.norm.plusinexpression = cna.HNC.norm[ which(rownames(cna.HNC.norm) %in% ID2),]
rm(ID2)

#Combine Expression and CNA data in one data frame for plotting and k-mean clustering 
comb.ex.cna = do.call(rbind, Map(data.frame, expression=expression.norm.plusinCNA, CNA=CNA.norm.plusinexpression))

#remove CNA and expression values below 0
comb.ex.cna <- comb.ex.cna[which(comb.ex.cna$CNA >= 2),]
comb.ex.cna <- comb.ex.cna[which(comb.ex.cna$expression >=0),]
#remove rows with missing values
comb.ex.cna<- comb.ex.cna[complete.cases(comb.ex.cna),]

#Plotting of normalized expression valuess against CNA data. 
ggplot(comb.ex.cna, aes(x= expression, y= CNA , color = "smooth")) + geom_point()

#ellbow method to find optimal ammount of clusters
emp = vector() #create an empty vector to save the summ-of weights scores
for (i in 1:10) emp[i] = sum(kmeans(comb.ex.cna, i)$withinss) #calculate the sum within squared values for 10 clusters
emp #look at the sum within squares for 10 clusters 

plot(1:10,
     emp,
     type = 'b',
     main = paste('The Elbow Method'),
     xlab = 'Number of clusters',
     ylab = 'EMP') 
# shows 3 clusters are sufficient

#k-mean of expression and CNA data
m=as.matrix(cbind(comb.ex.cna$expression, comb.ex.cna$CNA),ncol=2)
cl=(kmeans(m,3,iter.max = 10, nstart = 1))
comb.ex.cna$cluster=factor(cl$cluster)
centers=as.data.frame(cl$centers)

ggplot(data=comb.ex.cna, aes(x=expression, y=CNA, color=cluster )) + 
  geom_point() + 
  geom_point(data=centers, aes(x=V1,y=V2, color="Center")) +
  geom_point(data=centers, aes(x=V1,y=V2, color="Center"), size=12, alpha=.3, legend=FALSE)

rm(cl,m, centers)

# Fitting K-Means to the dataset
set.seed(2000) #set random variables
kmeans = kmeans(x = comb.ex.cna, centers = 3) #see elbow method (k = 5) and apply kMeans clustering onto the dataset of the customers
y_kmeans = kmeans$cluster #the consumers get put into a specific cluster; extract this information 
y_kmeans #look at the clusters for all the consumers

# Visualising the clusters
clusplot(comb.ex.cna,
         y_kmeans,
         lines = 0,
         shade = TRUE,
         color = TRUE,
         labels = 6,
         plotchar = FALSE,
         span = TRUE,
         main = paste('Clusters of Genes'),
         xlab = 'Expression',
         ylab = 'CNA')

#Visualisation of clusters 2
mtx = pam(comb.ex.cna,3)
fviz_cluster(mtx,
             lables =1,
             stand = TRUE,
             ellipse = TRUE,
             ellipse.type = "convex",
              shape = NULL,
             pointsize = 1.5,
             labelsize = 1,
             main = "Clusters of genes",
             xlab = "expression",
             ylab = "CNA")
rm(mtx)
             
```
## k-means with of expression number and CNA data in relation to reference samples (/reference)
```{r}
#Definition of related expression values
expr.HNC.rel = as.data.frame(apply(expression.HNC, 2, function(x) {
    x / mean.exp.reference
}))
#Definition of related CNA values
CNA.HNC.rel = as.data.frame(apply(copynumber.HNC, 2, function(x) {
              x / copynumber.ref.mean
              }))


#Remove values, that are either in expression data or CNA data
ID1 = rownames(copynumber.HNC)
expression.rel.plusinCNA = expr.HNC.rel[ which(rownames(expr.HNC.rel) %in% ID1),]
rm(ID1)

ID2 = rownames(expression.norm.plusinCNA)
CNA.rel.plusinexpression = CNA.HNC.rel[ which(rownames(CNA.HNC.rel) %in% ID2),]
rm(ID2)

#Combine Expression and CNA data in one data frame for plotting and k-mean clustering 
comb.rel.ex.cna = do.call(rbind, Map(data.frame, expression=expression.rel.plusinCNA, CNA=CNA.rel.plusinexpression))

#remove CNA and expression values below 0
comb.rel.ex.cna <- comb.rel.ex.cna[which(comb.rel.ex.cna$CNA >= 0),]
comb.rel.ex.cna <- comb.rel.ex.cna[which(comb.rel.ex.cna$expression >=0),]
comb.rel.ex.cna <- comb.rel.ex.cna[which(comb.rel.ex.cna$CNA <= 20),]
comb.rel.ex.cna <- comb.rel.ex.cna[which(comb.rel.ex.cna$expression <=20),]
#remove rows with missing values
comb.rel.ex.cna<- comb.rel.ex.cna[complete.cases(comb.rel.ex.cna),]

#Plotting of normalized expression valuess against CNA data. 
ggplot(comb.rel.ex.cna, aes(x= expression, y= CNA , color = "smooth")) + geom_point()
```
result of related values: not necessary --> no advantage against normalized values

## Investigate high frequencies of deleterious mutations
```{r}
mutation.HNC.del = lapply(1:length(ID), function(a) {
  out = mutation.HNC[[a]][which(mutation.HNC[[a]]$isDeleterious == TRUE),] # choose only deleterious mutations
  return(out)
})

mutation.HNC.del.df = do.call(rbind, mutation.HNC.del) # all mutation data of HNC samples in one dataframe

heatmap.genes = as.data.frame(table(mutation.HNC.del.df$Hugo_Symbol)) # dataframe with all mutated genes in HNC samples

heatmap.samples = lapply(1:(length(ID)), function(a) {
  heatmap.genes$a = ifelse(heatmap.genes$Var1 %in% mutation.HNC[[a]]$Hugo_Symbol, 1, 0) # per HNC sample: every gene which is mutated gets a 1, otherwise a 0
})

# define row and column names
heatmap.data = as.data.frame(do.call(cbind, heatmap.samples))
rownames(heatmap.data) = heatmap.genes$Var1
colnames(heatmap.data) = ID

# Order from high to low frequency
heatmap.data$mean = apply(heatmap.data, 1, sum)
heatmap.data = heatmap.data[order(-heatmap.data$mean), 1:27] 

# heatmap
heatmap(data.matrix(heatmap.data)[1:40,], Rowv=NA, Colv=NA, col = c("lightgrey", "tomato2"), scale="column", cexRow = 0.5, cexCol = 0.8)

# clean up the enviroment
rm(heatmap.genes, heatmap.samples)
```

![](images/frequent_mutations_HNC.png)

```{r}
goi.lit = data.frame(Gene = c("CDKN2A", "TP53", "CCND1", "EGFR", "PIK3CA", "PTEN", "FAT1", "AJUBA", "NOTCH1", "KMT2D", "NSD1"), Mutation_frequency = c(22, 72, 0.6, 4, 18, 3, 23, 7, 18, 16, 12), CNA_frequency = c(32, 1.4, 25, 11, 21, 4, 8, 1, 4, 0.4, 0.8)) # create dataframe with goi from literature

heatmap_position = lapply(1:nrow(goi.lit), function(a) { 
  out = grep(goi.lit$Gene[a], rownames(heatmap.data), value = FALSE) # get the position of goi.lit genes in our heatmap
  return(out[1])
})
goi.lit$Heatmap_position = do.call(rbind, heatmap_position) # add heatmap position to goi.lit
rm(heatmap_position)
goi.lit = goi.lit[order(goi.lit$Heatmap_position),]
goi.lit

goi.mut = rownames(heatmap.data)[1:5] # choose the 5 gene with most frequent deleterious mutation
```

# 3. Find SL/SDL partner

## SL-parter (Bonferroni correction needs to be added)
### SoF
```{r}
SL.SoF = lapply(1:length(goi.mut), function(m) {
  goi = goi.mut[m] # set 1 of 5 goi

  mutated.ID = lapply(1:length(mutation), function(a) {
    out = ifelse(goi %in% mutation[[a]]$Hugo_Symbol, a, NA) # filter all IDs which have a mutation of goi
    return(out)
  })

  not_mutated.ID = grep("NA", mutated.ID, value = FALSE) # ID of samples with no goi mutation
  mutated.ID = mutated.ID[is.na(mutated.ID) == FALSE] # ID of samples with goi mutation
  mutated.ID = as.integer(mutated.ID)

  p.value = lapply(1:nrow(copynumber), function(b) {
    mutated.cna = t(copynumber[b, mutated.ID])
    not_mutated.cna = t(copynumber[b, not_mutated.ID])
    p = wilcox.test(mutated.cna, not_mutated.cna, alternative = "greater")$p.value # one sided (greater) Wilcoxon Sum Rank Test 
  })

  out = data.frame(genes = rownames(copynumber), p_value = do.call(rbind, p.value))
  out = out[which(out$p_value < 0.05),]
  return(out)
})
names(SL.SoF) = goi.mut
```
### Functional examination
```{r}
SL.functional.examination = lapply(1:length(goi.mut), function(m) {
  goi = goi.mut[m] # set 1 of 5 goi

  mutated.ID = lapply(1:length(mutation), function(a) {
    out = ifelse(goi %in% mutation[[a]]$Hugo_Symbol, a, NA) # filter all IDs which have a mutation of goi
    return(out)
  })

  not_mutated.ID = grep("NA", mutated.ID, value = FALSE) # ID of samples with no goi mutation
  mutated.ID = mutated.ID[is.na(mutated.ID) == FALSE] # ID of samples with goi mutation
  mutated.ID = as.integer(mutated.ID)

  p.value = lapply(1:nrow(kd.ceres), function(b) {
    mutated.kd = t(kd.ceres[b, mutated.ID])
    not_mutated.kd = t(kd.ceres[b, not_mutated.ID])
    p = wilcox.test(mutated.kd, not_mutated.kd, alternative = "less")$p.value # one sided (less) Wilcoxon Sum Rank Test 
  })

  out = data.frame(genes = rownames(kd.ceres), p_value = do.call(rbind, p.value))
  out = out[which(out$p_value < 0.05),]
  return(out)
})
names(SL.functional.examination) = goi.mut
```
### Gene coexpression

## SDL-parter
### SoF
### Functional examination
### Gene coexpression

## Converging the different SL and SDL sets

# 4. Mutation prediction via logistical regression

## Examine correlation between variables
## train regression model
## test regression model and compare different variable input