---
title: "Project Head and Neck Cancer"
author: "Nils Mechtel, Tobias Hub, Niklas Urbanek, Pascal Poc"
date: "6 Mai 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
root.dir = dirname(rstudioapi::getSourceEditorContext()$path)
library(ggplot2)
library(ggpubr) # histograms
theme_set(theme_pubr())
library(png)
library(tidyverse)  # data manipulation
library(cluster)    # clustering algorithms
library(factoextra) # clustering algorithms & visualization
library(igraph)     # networkplot 


'%!in%' <- function(x,y)!('%in%'(x,y)) # Define function "is not in"
```

# General Introduction
Head and neck cancer is defined as a group of cancers, concerning the mouth, nose and throat. With over 90%, Squamous cell carcinoma is the most common type in HNC patients.With 5.5 million affected people in 2015 it is the seventh most frequent cancer and the ninth most frequent cause of death. (Information required)


![](images/HNC_Kopf.png)
In the century of next generation sequencing, the genome became an interesting target for scientists.Approaches that directly affect important oncogenes often fail due to the fact that these genes play an important role in healthy cells.The researchers in our paper investigated synthetic lethality and synthetic dosage lethality that uses gene interactions to affect tumorous proliferation. Synthetic letahlity is a gene interaction in which single-gene defects are compatible with cell viability, but the combination of gene effects results in cell death.Synthetic dosage lethality occurs, when the overexpression of one gene is combined with the knockout of another gene.

![](images/Daisy.png)



# 1. Data Cleanup & Descriptive Statistics

## Loading data and defining HNC variables
```{r}
# Load dataset
allDepMapData = readRDS("DepMap19Q1_allData.RDS")

# Creation of sub matrices
expression = allDepMapData[["expression"]]
copynumber = allDepMapData[["copynumber"]]
mutation = allDepMapData[["mutation"]]
kd.ceres = allDepMapData[["kd.ceres"]]
kd.prob = allDepMapData[["kd.prob"]]
annotation = allDepMapData[["annotation"]]
rm(allDepMapData)

# Reducing the samples to head and neck cancer samples
annotation.HNC = annotation[which(annotation$Primary.Disease == "Head and Neck Cancer"), ]
ID = annotation.HNC$DepMap_ID

# Filtering of sub matrices by primary disease "Head and neck cancer"
expression.HNC = expression[ , which(colnames(expression) %in% ID)]
copynumber.HNC = copynumber[ , which(colnames(copynumber) %in% ID)]
kd.ceres.HNC = kd.ceres[ , which(colnames(kd.ceres) %in% ID)]
kd.prob.HNC = kd.prob[ , which(colnames(kd.prob) %in% ID)]
mutation.HNC = mutation[ID]
```

## Expression analysis

### Checking fo NAs
```{r}
sum(is.na(expression) == TRUE)
```
There are no NAs in the expression data.

### Examine expression values

Comparing mean gene expression of all samples with just HNC samples.
```{r}
expression.reference = expression[ , which(colnames(expression) %!in% ID)]
mean.exp.reference = apply(expression.reference, 1, mean)
mean.exp.HNC = apply(expression.HNC, 1, mean)
```
Checking if expression is normally distributed
```{r}
HNC = data.frame(expression_values = mean.exp.HNC, sample = "HNC")
reference = data.frame(expression_values = mean.exp.reference, sample = "reference")
mean.expression = rbind(reference, HNC)

ggqqplot(mean.expression, x = "expression_values",
   color = "sample",
   palette = c("#FC4E07", "#0073C2FF"),
   ggtheme = theme_pubclean())

rm(HNC, reference, mean.expression)
```
Result: Gene espression is not normally distributed.

Applying Wilcoxon rank sum test because expression is not normally distributed
```{r}
wilcox.test(mean.exp.HNC, mean.exp.reference)
```
Result: Mean gene expression differs between HNC samples and all samples significantly.

Comparing mean TP53 gene expression of all samples with and without deleterious TP53 mutation
```{r}
TP53.mut.ID = lapply(1:length(mutation), function(a) {
  dat_picker = mutation[[a]]
  dat_picker = dat_picker[which(dat_picker$isDeleterious == TRUE),]
  out = ifelse("TP53" %in% dat_picker$Hugo_Symbol, a, NA) # filter all IDs which have a deleterious mutation of TP53
    return(out)
  })

TP53.not_mut.ID = grep("NA", TP53.mut.ID, value = FALSE) # ID of samples with no TP53 mutation
TP53.mut.ID = as.integer(TP53.mut.ID[is.na(TP53.mut.ID) == FALSE]) # ID of samples with TP53 mutation

exp.TP53.mut = as.numeric(expression["TP53", TP53.mut.ID]) # expression of TP53 deleterious mutated samples
exp.TP53.not_mut = as.numeric(expression["TP53", TP53.not_mut.ID]) # expression of TP53 not deleterious mutated samples
```
Applying Wilcoxon rank sum test because expression is not normally distributed
```{r}
wilcox.test(exp.TP53.mut , exp.TP53.not_mut)
rm(TP53.mut.ID, TP53.not_mut.ID, exp.TP53.mut, exp.TP53.not_mut)
```
Result: Gene expression of TP53 as an example gene varies significantly whether the samples has or has no deleterious TP53 mutation.

Checking how the expression values are distributed
```{r}
# histogram
gghistogram(as.data.frame(mean.exp.HNC), x = "mean.exp.HNC", xlab = "expression value", bins = 60,
            fill = "#0073C2FF", color = "#0073C2FF",
            add = "mean", rug = TRUE)
```
### Normalize expression data from HNC samples
```{r}
expr.HNC.norm = as.data.frame(apply(expression.HNC, 2, function(x) {
  x - mean.exp.reference
}))
```
### Plotting the 20 most under- and overexpressed genes of the first sample
```{r}
mean.expr.HNC.norm = as.data.frame(apply(expr.HNC.norm, 1, mean))
barplot.data = data.frame(Genes=rownames(expr.HNC.norm),Values=mean.expr.HNC.norm)
names(barplot.data) = c("Genes", "Values")
barplot.data$Group<-ifelse(barplot.data$Values>0,"overexpressed","underexpressed")
barplot.data = barplot.data[order(barplot.data$Values),]
barplot.data = barplot.data[c(1:19, (nrow(barplot.data)-20):nrow(barplot.data)),]
ggplot(barplot.data,aes(x=Genes,y=Values,fill=Group))+geom_bar(stat="identity")+coord_flip()+theme(axis.text.y = element_text(size=6))
rm(mean.expr.HNC.norm, barplot.data)
```
### Cleanup of the enviroment
```{r}
rm(mean.exp.HNC, mean.exp.reference, expression.reference)
```

## Copynumber Alteration
### Analysis of NA values

Examination of NA values in the copynumber.HNC data
```{r}
# sum up all NAs in each row
NA.rows = apply(copynumber.HNC,1, function(x) {
          sum(is.na(x))
})
#define all rows cotaining missing values
NA.rows = which( NA.rows > 0)
length(NA.rows)
```
Only 107 out of 23299 gens have NA values and are therefore deleted from the copynumber.HNC matrix
```{r}
copynumber.HNC = copynumber.HNC[-NA.rows,]
dim(copynumber.HNC)
```
Creating a reference data and examination of its NA values
```{r}
copynumber.reference = copynumber[,which(colnames(copynumber) %!in% ID)]
dim(copynumber.reference)
```

```{r}
NA.rows.ref = apply(copynumber.reference,1, function(x) {
          sum(is.na(x))
})
NA.rows.ref = which( NA.rows.ref > 0)
length(NA.rows.ref)
```

```{r}
summary(NA.rows == NA.rows.ref)
```
Genes with NA values are the same for the HNC samples and all the other samples. Therefore, they can be deleted in the reference data as well.

```{r}
copynumber.reference = copynumber.reference[-NA.rows.ref,]
copynumber = copynumber[-NA.rows.ref,]
dim(copynumber.reference)
dim(copynumber)
```
### Normalisation of the copynumber values

For the HNC normalisation we will use the mean CN value per gen of the reference data.

```{r}
copynumber.ref.mean = apply(copynumber.reference,1, mean)

copynumber.HNC.mean = apply(copynumber.HNC ,1, mean)
```

Creating a matrix of HNC copynumber values. The values are normalized to the mean copynumbers of the reference data. For further analysing the matrix is ordered in a decreasing manner.
```{r}
copynumber.HNC.norm = copynumber.HNC.mean - copynumber.ref.mean
copynumber.HNC.norm = as.data.frame(copynumber.HNC.norm[order(copynumber.HNC.norm, decreasing = TRUE )])
copynumber.HNC.norm$genes = row.names(copynumber.HNC.norm)
```
Creating a dataframe of all copynumber values. The values are normalized to the mean copynumbers of the reference data.
```{r}
cna.HNC.norm = as.data.frame(apply(copynumber.HNC, 2, function(x) {
  x - copynumber.ref.mean
}))
```

Plotting genes with the highest and lowest copynumbers.
```{r}
copynumber.HNC.norm$Group <- ifelse(copynumber.HNC.norm$copynumber.HNC.norm > 0,"high CN","low CN")
ggplot(copynumber.HNC.norm[c(1:20,23172:23192),],aes(x=genes,y=copynumber.HNC.norm,fill=Group))+geom_bar(stat="identity")+coord_flip()+theme(axis.text.y = element_text(size=6))
```
### Cleanup of the environment
```{r}
rm(NA.rows, NA.rows.ref, copynumber.HNC.norm, copynumber.HNC.mean, copynumber.ref.mean, copynumber.reference)
```

## Mutation

### Find Mutations with the highest frequencies

Melt all mutation matrices together and find most often mutated genes over all samples
```{r}
all_mutations = do.call(rbind,mutation)
all_mutated_genes = table(all_mutations$Hugo_Symbol)
all_mutated_genes_df = as.data.frame(all_mutated_genes)
ID_all_highest_frequencies = head(order(all_mutated_genes_df[["Freq"]], decreasing = TRUE), 30)
all_mutated_genes_df_highest_30 = all_mutated_genes_df[which(rownames(all_mutated_genes_df) %in% ID_all_highest_frequencies), ]
ID_all_highest_30_frequencies = order(all_mutated_genes_df_highest_30["Freq"], decreasing = TRUE) 
all_mutated_genes_df_highest_30_ordered = all_mutated_genes_df_highest_30[ID_all_highest_30_frequencies, ]
rownames(all_mutated_genes_df_highest_30_ordered) = 1:30
colnames_ordered = c("Gene", "Freq")
colnames(all_mutated_genes_df_highest_30_ordered) = colnames_ordered
```

Melt only HNC sample mutation matrices together and find most often mutated genes 
```{r}
HNC_mutations = do.call(rbind, mutation.HNC)
HNC_mutated_genes = table(HNC_mutations$Hugo_Symbol)
HNC_mutated_genes_df = as.data.frame(HNC_mutated_genes)
ID_HNC_highest_frequencies = head(order(HNC_mutated_genes_df[["Freq"]], decreasing = TRUE), 27)  
HNC_mutated_genes_df_highest_ordered = HNC_mutated_genes_df[ID_HNC_highest_frequencies, ]
rownames(HNC_mutated_genes_df_highest_ordered) = 1:27
colnames(HNC_mutated_genes_df_highest_ordered) = colnames_ordered
```

### Plotting mutation frequencies of all samples and of HNC samples

Plot mutations in all samples
```{r}
all_mut_plot = ggplot(data = all_mutated_genes_df_highest_30_ordered, aes(x=Gene, y=Freq)) + geom_bar(stat = "identity", width = 0.5, fill="steelblue") +  geom_text(aes(label=Freq), vjust=-0.3, size=2.5) + theme_grey() + coord_flip()

all_mut_plot
```

Plot mutations in HNC samples
```{r}
HNC_mut_plot = ggplot(data = HNC_mutated_genes_df_highest_ordered, aes(x=Gene, y=Freq)) + geom_bar(stat = "identity", width = 0.5, fill="steelblue") + geom_text(aes(label=Freq), vjust=-0.3, size=3.5) + theme_grey()+ coord_flip()
HNC_mut_plot
```
### Cleanup of the enviroment
```{r}
rm(all_mutations, all_mutated_genes, all_mutated_genes_df, ID_all_highest_30_frequencies, ID_all_highest_frequencies, all_mutated_genes_df_highest_30, all_mutated_genes_df_highest_30_ordered, colnames_ordered, HNC_mutations, HNC_mutated_genes, HNC_mutated_genes_df, ID_HNC_highest_frequencies, HNC_mutated_genes_df_highest_ordered, HNC_mut_plot, all_mut_plot)
```

## Knockdown

### Checking for NAs and range in HNC patients
```{r}
sum(is.na(kd.ceres.HNC) == TRUE) #NAs
range(kd.ceres.HNC)# Range of data
```
### Definition of a compare group
```{r}
kd.ceres.reference = kd.ceres[ , -which(colnames(kd.ceres) %in% ID)]

# Comparing mean knockdown data of all samples with just HNC samples
mean.kd.ceres.reference = apply(kd.ceres.reference, 1, mean)
mean.kd.ceres = apply(kd.ceres.HNC, 1, mean)

# Checking if knockdown values are normally distributed
kd.ceres.HNC.dist = data.frame(kd_values = mean.kd.ceres, sample = "Knockdown HNC")
kd.ceres.reference.dist = data.frame(kd_values = mean.kd.ceres.reference, sample = "reference HNC")
mean.kd.ceres.dist = rbind(kd.ceres.reference.dist, kd.ceres.HNC.dist)

ggqqplot(mean.kd.ceres.dist, x = "kd_values",
   color = "sample",
   palette = c("#FC4E07", "#0073C2FF"),
   ggtheme = theme_grey())

# Are there genes that tend to be more essential in HNC?
esgene1 = kd.ceres.HNC[-which(rowMeans(kd.ceres.HNC)> rowMeans(kd.ceres.reference)),]
#Sort essential genes 
esgene1= esgene1[order(rowMeans(esgene1)),]

```
result: kd.ceres values are not normal distributed

### Checking the distribution for knockdown values
```{r}
gghistogram(kd.ceres.HNC.dist, x = "kd_values", xlab = "knockdown values", bins = 60,
            fill = "#0073C2FF", color = "#0073C2FF",
            add = "mean", rug = TRUE)+theme_grey()
```
### Applying Wilcoxon rank sum test because knockdown values are not normally distributed
```{r}
wilcox.test(mean.kd.ceres, mean.kd.ceres.reference)
```
Resultat Fehlt
### Example EGFR
```{r}
# Transposition of matrix esgene1
esgeneT <- as.data.frame(t(esgene1))
summary(esgeneT$EGFR)
```

### Boxplot of 20 genes
```{r}
#boxplot of 20 of most significiant genes according to knockdown analysis
boxplot(esgeneT[,1:20], xlab = "gene", horizontal = F, main="Knockdown values of most significiant genes",
        xlab="genes",
        ylab="Knockdown values",
        col="blue",
        border="brown",
        outline = TRUE,
        notch = TRUE)
abline(col = c("blue", "red", "black", "orange"),
    lty = 2)
```
### Cleanup of the enviroment
```{r}
rm(kd.ceres.HNC.dist, kd.ceres.reference, kd.ceres.reference.dist, mean.kd.ceres, mean.kd.ceres.reference, mean.kd.ceres.dist, esgene1, esgeneT)
```

# 2. Identify genes of interest

## k-means clustering of CNA and expression data with normalized values(-reference) for SDL GOI

```{r}
km.genes = Reduce(intersect, list(rownames(expression.HNC), rownames(copynumber.HNC)))
km.expression = expr.HNC.norm[km.genes,]
km.copynumber = cna.HNC.norm[km.genes,]
km.data = lapply(1:length(ID), function(x) {
  out = data.frame(genes =km.genes, expression = km.expression[,x], copynumber = km.copynumber[,x])
  return (out)
})

comb.ex.cna = do.call(rbind, km.data)
comb.ex.cna <- comb.ex.cna[which(comb.ex.cna$copynumber >= 1 & comb.ex.cna$expression >=quantile(comb.ex.cna$expression,0.95)),]

#Plotting of normalized expression valuess against CNA data. 
ggplot(comb.ex.cna[,2:3], aes(x= expression, y= copynumber , color = "smooth")) + geom_point()

#ellbow method to find optimal ammount of clusters
emp = vector() #create an empty vector to save the summ-of weights scores
for (i in 1:10) emp[i] = sum(kmeans(comb.ex.cna[2:3], i)$withinss) #calculate the sum within squared values for 10 clusters
emp #look at the sum within squares for 10 clusters 
#Plotting of Ellbow method
plot(1:10,
     emp,
     type = 'b',
     main = paste('The Elbow Method'),
     xlab = 'Number of clusters',
     ylab = 'EMP') 
# shows 3 clusters are sufficient

# Fitting K-Means to the dataset
kmeans = kmeans(x = comb.ex.cna[,2:3], centers = 3,iter.max = 1000, nstart = 1) #see elbow method (k = 5) and apply kMeans clustering onto the dataset of the customers
y_kmeans = kmeans$cluster #the consumers get put into a specific cluster; extract this information 

# Visualising the clusters
clusplot(comb.ex.cna,
         y_kmeans,
         lines = 0,
         shade = TRUE,
         color = TRUE,
         labels = 4,
         plotchar = FALSE,
         span = TRUE,
         stand = FALSE,
         cex =0.5,
         main = paste('Clusters of Genes'),
         xlab = 'Expression',
         ylab = 'CNA')

comb.ex.cna = cbind(comb.ex.cna, y_kmeans)#combine kmeans with genes
#sort comb.ex.cna data decresing for selecting adequate number of cluster
comb.ex.cna = comb.ex.cna[order(comb.ex.cna$expression,decreasing =TRUE),]

#Filtering of the most expressed and alterated
goi.sdl = comb.ex.cna[which(comb.ex.cna$y_kmeans == comb.ex.cna[1,4]),]

#sort matrix 
goi.sdl = goi.sdl[order(goi.sdl$expression,decreasing=TRUE),] 
head(goi.sdl)

goi.SDL = as.character(goi.sdl$genes[1:5]) # !goi.SDL need to be a vector of 5 gene names for milestone 3!
rm(emp, i, km.genes, y_kmeans, kmeans, km.copynumber, km.data, km.expression, comb.ex.cna) # Clean enviroment
```
## Investigate high frequencies of deleterious mutations
```{r}
mutation.HNC.df = do.call(rbind, mutation.HNC) # all mutation data of HNC samples in one dataframe
heatmap.genes = as.data.frame(table(mutation.HNC.df$Hugo_Symbol)) # dataframe with all mutated genes in HNC samples once

heatmap.data = as.data.frame(sapply(1:(length(ID)), function(a) {
  out = ifelse(heatmap.genes$Var1 %in% mutation.HNC[[a]]$Hugo_Symbol, 1, 0) # per HNC sample: every gene which is mutated gets a 1, otherwise a 0
  return(out)
}))

# define row and column names
rownames(heatmap.data) = heatmap.genes$Var1
colnames(heatmap.data) = ID

# Order from high to low frequency
heatmap.data$sum = apply(heatmap.data, 1, sum)
heatmap.data = heatmap.data[order(-heatmap.data$sum), 1:27] 

# heatmap of the most frequently mutated genes in HNC samples
heatmap(data.matrix(heatmap.data)[1:40,], Rowv=NA, Colv=NA, col = c("lightgrey", "tomato2"), scale="column", cexRow = 0.5, cexCol = 0.8, main = "Most frequently mutated genes in HNC samples")

# clean up the enviroment
rm(mutation.HNC.df, heatmap.genes)
```

![](images/frequent_mutations_HNC.png)

```{r}
goi.lit = data.frame(Gene = c("CDKN2A", "TP53", "CCND1", "EGFR", "PIK3CA", "PTEN", "FAT1", "AJUBA", "NOTCH1", "KMT2D", "NSD1"), Mutation_frequency = c(22, 72, 0.6, 4, 18, 3, 23, 7, 18, 16, 12), CNA_frequency = c(32, 1.4, 25, 11, 21, 4, 8, 1, 4, 0.4, 0.8)) # create dataframe with goi from literature

heatmap_position = lapply(1:nrow(goi.lit), function(a) { 
  out = grep(goi.lit$Gene[a], rownames(heatmap.data), value = FALSE) # get the position of goi.lit genes in our heatmap
  return(out[1])
})
goi.lit$Heatmap_position = do.call(rbind, heatmap_position) # add heatmap position to goi.lit
rm(heatmap_position)
goi.lit = goi.lit[order(goi.lit$Heatmap_position),]
goi.lit

goi.SL = rownames(heatmap.data)[1:5] # choose the 5 gene with most frequent deleterious mutation

rm(heatmap.data)
```

# 3. Find SL/SDL partner
## Define functions for SL/SDL partner search
Define function for Wilcoxon sum rank test following the daisy model. (Bonferroni correction needs to be added)
```{r}
'Daisy.Wilcox' <- function(input_genes,input_data, inactive_overactive, less_greater){
  Daisy_Wilcox = lapply(1:length(input_genes), function(m) {
  goi = input_genes[m] # set 1 of 5 goi
  # depending on SL or SDL partner search gene B needs to be inactive (SL) or overactive (SDL)
  if(inactive_overactive == 1) { # inactive_overactive == 1 chooses overactive
    mean.exp.goi = mean(t(expression[goi,]))
    exp.goi.norm = expression[goi,] - mean.exp.goi # normalised expression values of goi
    mut_overa.ID = lapply(1:ncol(expression), function(a) {
    out = if(exp.goi.norm[goi, a] > 0 & copynumber[goi,a] > 0.3) {a} else {NA} # filter all IDs which are overactive: overexpressed and CNA > 0,3
    return(out)
    })
  } else { # inactive_overactive == 0 chooses inactive
    mut_overa.ID = lapply(1:length(mutation), function(a) {
    out = ifelse(goi %in% mutation[[a]]$Hugo_Symbol, a, NA) # filter all IDs which have a mutation of goi
    return(out)
    })
  }
  
  not_mut_overa.ID = grep("NA", mut_overa.ID) # ID of samples which have NO inactivity/overactivity of goi
  mut_overa.ID = as.integer(mut_overa.ID[is.na(mut_overa.ID) == FALSE]) # ID of samples which HAVE inactivity/overactivity of goi

  p.value = sapply(1:nrow(input_data), function(b) {
    mut_overa.data = t(input_data[b, mut_overa.ID])
    not_mut_overa.data = t(input_data[b, not_mut_overa.ID])
    if (less_greater == 1) {
      p = wilcox.test(mut_overa.data, not_mut_overa.data, alternative = "greater")$p.value # one sided (greater) Wilcoxon Sum Rank Test 
    } else {
      p = wilcox.test(mut_overa.data, not_mut_overa.data, alternative = "less")$p.value # one sided (greater) Wilcoxon Sum Rank Test
    }
    
  })

  out = data.frame(genes = rownames(input_data), p_value = p.value)
  out = out[which(out$p_value < 0.05),]
  return(out)
  })
  names(Daisy_Wilcox) = input_genes
  return(Daisy_Wilcox)
}
```
Define function for Spearman correlation test following the daisy model.

To examine gene pairs A and B which fulfill the criteria of gene co expresssion we performe a Spearman correlation test on the expression data. Therefore the 5 most frequently mutated genes detected in the second milstone are defined as genes A. The correlation test now returns all genes B that correlate to gen A in a significant manner. 
```{r}
'Daisy.Spearman' <- function(input_genes){
  Daisy_Spearman = lapply(1:length(input_genes), function(m) { # build up a list with the 5 goi, first       lapply: goes through the code for each gene A
  goi = input_genes[m]

  p.value = sapply(1:nrow(expression), function(a){  # creation of a list with the length of the expression   data, for the reacent goi, go through every gene and calculate cor.test
    expression.goi =t(expression[goi,])           # variable containing expressiondata of the goi (gene A)
    expression.GeneB =t(expression[a,])           # variable containing all other genes (gene B)
    p = cor.test(expression.goi,expression.GeneB, alternative = "greater", method = "spearman", exact = FALSE)$p.value # one sided spearman correlation test  
  })
  
  # return a dataframe with the columns genes(HugoSymbols) and p_values (p.values)
  out = data.frame(genes = rownames(expression), p_value = p.value)
  out = out[which(out$p_value < 0.05),] # filter for significant p.values
  out = out[which(out$genes != goi),]   # select onl these wich are not the same gene as the goi (would be a corr of 1)
  return(out)
  })
  names(Daisy_Spearman) = input_genes
  return(Daisy_Spearman)
}
```
The returned list, contains the five genes of interest as elements each containing a dataframe with all genes examined as potential SL partners additional with there calculated p-values.

Define function to converge SL/SDL sets.
```{r}
'partner' <- function(input_genes, SoF, functional.examination, coexpression){
  partner = lapply(1:length(input_genes), function(a) {
    dat_picker.SoF = SoF[[a]]
    dat_picker.functional_examination = functional.examination[[a]]
    dat_picker.coexpression = coexpression[[a]]
    partnergenes = Reduce(intersect, list(dat_picker.SoF$genes, dat_picker.functional_examination$genes, dat_picker.coexpression$genes))
    out = data.frame(genes = partnergenes,
                     SoF = dat_picker.SoF[which(dat_picker.SoF$genes %in% partnergenes),"p_value"],
                     functional_examination = dat_picker.functional_examination[which(dat_picker.functional_examination$genes %in% partnergenes),"p_value"],
                     coexpression = dat_picker.coexpression[which(dat_picker.coexpression$genes %in% partnergenes),"p_value"])
    return(out)
  })
  names(partner) = input_genes
  return(partner)
}
```
Define function to reduce SL/SDL partner to the most significants
```{r}
'reduce.partner' <- function(list, keep_element){
  reduced_partner = lapply(1:length(list), function(a){
    dat_picker = list[[a]]
    ordered_data = dat_picker[order(dat_picker$SoF, dat_picker$functional_examination, dat_picker$coexpression),]
    if (nrow(dat_picker) > 20) { # (1) if length of dat_picker is larger than 20 reduce to the 20 most significant
      
      if (keep_element %in% ordered_data$genes) { # (2) if keep_element is in ordered_data then return first 20 entries plus keep_element
        position.keep_element = grep(keep_element, ordered_data$genes) # search for position of keep_element
        
        if (position.keep_element > 20) {
          out = ordered_data[c(1:19, position.keep_element),] # (3) keep_element is not in the first 20 elements and needs to be extra added
        } else {
          out = ordered_data[1:20,] # (3) keep_element is in the first 20 elements and don´t need to be extra added
        }
        
      } else {
        out = ordered_data[1:20,] # (2) if keep_element is not in ordered_data just return first 20 entries
      }
      return(out) # return reduced data
      
    } else {
      return(ordered_data) # (1) return data unreduced if length of dat_picker is smaller than 20
    }
  })
  names(reduced_partner) = names(list)
  return(reduced_partner)
}  
```
Create dataframe containing 3 colums. first: Gen.A, second: Gene.B third: colours
```{r}

color.vector = as.character(c("darkred", "darkgreen", "turquoise", "yellow", "orange"))

"network" = function(X.partner){
  edgelist = lapply(1:length(X.partner), function(a){
    dat_picker = X.partner[[a]]
    edge.list = data.frame(Gene.A = names(X.partner)[a], Gene.B = dat_picker$genes, colours = color.vector[a])
  })
  edge.list = do.call(rbind, edgelist)#combine all goi-dataframes to one.
}

```

## SL-parter
SoF
```{r}
SL.SoF = Daisy.Wilcox(goi.SL, copynumber, inactive_overactive = 0, less_greater = 1) # SoF, one sided Wilcoxon rank test, alternative = "greater"
```
Functional examination
```{r}
SL.functional.examination = Daisy.Wilcox(goi.SL, kd.ceres, inactive_overactive = 0, less_greater = 0) # Functional examination, one sided Wilcoxon rank test, alternative = "less"
```
Gene coexpression
```{r warning=FALSE}
# Standardabweichung is NULL
SL.coexpression = Daisy.Spearman(goi.SL)
```

## SDL-parter
SoF
```{r}
SDL.SoF = Daisy.Wilcox(goi.SDL, copynumber, inactive_overactive = 1, less_greater = 1) # SoF, one sided Wilcoxon rank test, alternative = "greater"
```
Functional examination
```{r}
SDL.functional.examination = Daisy.Wilcox(goi.SDL, kd.ceres, inactive_overactive = 1, less_greater = 0) # Functional examination, one sided Wilcoxon rank test, alternative = "less"
```
Gene coexpression
```{r warning=FALSE}
SDL.coexpression = Daisy.Spearman(goi.SDL)
```
## Converging the different SL and SDL sets
```{r}
SL.partner = partner(goi.SL, SL.SoF, SL.functional.examination, SL.coexpression)
SDL.partner = partner(goi.SDL, SDL.SoF, SDL.functional.examination, SDL.coexpression)
data.frame("SL genes" = names(SL.partner),
           SL_partner = sapply(1:length(SL.partner), function(a){nrow(SL.partner[[a]])}),
           "SDL genes" = names(SDL.partner),
           SDL_partner = sapply(1:length(SDL.partner), function(a){nrow(SDL.partner[[a]])})
           )
```

## Plotting networks of the Interactions 

Creating a networkplot for the SL-partners
```{r warning=FALSE}
#create edge.list(dataframe) of SL partners
edge.list = network(SL.partner)
edge.list$colours = as.character(edge.list$colours)
#define "net" as an igraph objekt 
net = graph_from_data_frame(edge.list, directed = T)

#three different layouts already provided in the igraph package
layout1 = layout_with_kk(net)
layout2 = layout_with_fr(net)
layout3 = layout_nicely(net)

#plotting the network with several parameters. edge = connections between Genes, vertex = Genes 
plot(net, layout = layout2, rescale = T, ylim = c(-0.9,1), xlim = c(-0.02,-0.1), edge.color = edge.list$colours , edge.width = 2, edge.arrow.mode = 0, vertex.color = "grey", vertex.size = 8.1, vertex.label.font = 2, vertex.label.degree = -pi/2, vertex.label.color = "black", main = "Network of SL interaction" ) 

#adding a legend so the plot
legend (x = 1.2, y = 1, goi.SL,  fill = c("darkred", "darkgreen", "turquoise", "yellow", "orange")) 

# Cleanup of the environment
rm(net,edge.list,layout1,layout2,layout3)
```

creating a network for the SDL-partner 

```{r}
edge.list = network(SDL.partner) 
edge.list$colours = as.character(edge.list$colours) #convert the column-class from factor to character

#define "net" as an igraph objekt 
net= graph_from_data_frame(edge.list, directed = T)

layout = layout_with_fr(net)
#plotting the network with several parameters. edge = connections between Genes, vertex = Genes 
plot(net, layout = layout, rescale = T, ylim = c(-0.99,1), xlim = c(-0.02,-0.1), edge.color = edge.list$colours, edge.arrow.size = 0.1 , edge.width = 4, edge.arrow.mode = 1, vertex.color = "grey", vertex.frame.color = "grey", vertex.size = 12, vertex.label.font = 2, vertex.label.degree = -pi/2, vertex.label.color = "black", main = "Network of SDL interaction" ) 

#adding a legend so the plot
legend (x = 1.2, y = 1, goi.SDL,  fill = c("darkred", "darkgreen", "turquoise", "yellow", "orange")) 

# Cleanup of the environment
rm(net,edge.list,layout)
         
```

Reduce SL.parter/SDL.partner to the most significant
```{r}
SL.partner = reduce.partner(SL.partner, "...")
SDL.partner = reduce.partner(SDL.partner, "...")
data.frame("SL genes" = names(SL.partner),
           SL_partner = sapply(1:length(SL.partner), function(a){nrow(SL.partner[[a]])}),
           "SDL genes" = names(SL.partner),
           SDL_partner = sapply(1:length(SDL.partner), function(a){nrow(SDL.partner[[a]])})
           )
```

Plotting SL/SDL partner network with reduced number of partner
```{r}

```

# 4. Mutation prediction via logistical regression
## Prepare data for regression model
Reduce all genes to them of which we have expression, copynumber and knockdown data.
```{r}
regression.genes = Reduce(intersect, list(rownames(expression), rownames(copynumber), rownames(kd.ceres)))

regression.expression = expression[regression.genes,]
regression.copynumber = copynumber[regression.genes,]
regression.kd.ceres = kd.ceres[regression.genes,]
```
Create a dataframe with expression, copynumber, knockdown and mutation data from all samples one after another.
```{r}
regression.data = lapply(1:length(regression.genes), function(a) {
  rg.expr = t(regression.expression[a,])
  rg.cna = t(regression.copynumber[a,])
  rg.kd = t(regression.kd.ceres[a,])
  rg.mut = sapply(1:length(mutation), function(m) {
    out = ifelse(regression.genes[a] %in% mutation[[m]]$Hugo_Symbol, TRUE, FALSE)
    return(out)
  })
  out = data.frame("genes" = regression.genes[a], "expression" = rg.expr, "copynumber" = rg.cna, "kockdown" = rg.kd, "mutation" = rg.mut)
  colnames(out) = c("genes", "expression", "copynumber", "kockdown", "mutation")
  return(out)
})
regression.data = do.call(rbind, regression.data)
rm(regression.genes, regression.expression, regression.copynumber, regression.kd.ceres)
```
## train regression model
## test regression model and compare different variable input
